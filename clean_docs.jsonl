{"url": "https://in.mathworks.com/help/slrealtime/ug/installing-simulink-real-time-software-updates.html", "title": "Install Simulink Real-Time Software Updates", "markdown": "Install Simulink Real-Time Software Updates The general procedure for updating Simulink® Real-Time™ is: Navigate to the MathWorks® download page: Navigate to the page for the Simulink Real-Time software version that you want. Download the software version to your development computer. Install and integrate the new release software. After updating Simulink Real-Time, to re-create your Simulink Real-Time target settings: In the MATLAB® Command Window, type slrtExplorer. On the Targets Tree pane, select a target computer node. Click the Target Configuration tab. Click Change IP Address and select the IP Address and Netmask for communication method between your development and target computer. For more information, see Target Computer Settings. Click OK. Click the Disconnected link, toggling it to Connected. Repeat steps 2 through 5 for each target computer. Build each model that you want to execute. In the Simulink Editor, on the Real-Time tab, click Run on Target. Target Computer Settings To run a Simulink® Real-Time™ model on a Speedgoat® target computer, configure the target settings to match the capabilities of the target computer. Select the Simulink Real-Time template from the Simulink start page and create the exampleSlrtApp model. In the MATLAB® Command Window, type: simulink In the Simulink Editor, open the Simulink Real-Time Explorer. In the Real-Time tab, from the targets list, click SLRT Explorer. From the Target Computers list, select the target computer node. To add a node representing another target computer, in the Targets pane, click the Add target button. To remove a node representing a target computer, select the node and click the Remove target button. To connect to a target computer, toggle the Disconnected indicator to Connected. If not previously configured, select the Target Configuration tab and set the target computer IP address for the target computer definition by using the Change IP Address button. For example, Speedgoat target machines are preconfigured to IP address 192.168.7.5 and subnet mask 255.255.255.0. If your target machine has been used with a previous version of MATLAB and you have not yet migrated the target machine to release R2020b or later, you will see this message: Please enter the following at the MATLAB command prompt >> speedgoat.migrateTarget before continuing with the next step. Repeat this procedure as required for each target computer. Simulink Real-Time Explorer", "tags": ["R2020B"], "tokens": 471, "timestamp": "2025-05-03T14:44:29Z", "hash": "409219d07291a4c499bae1f836c63fe6"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/find-simulink-real-time-support.html", "title": "Find Simulink Real-Time Support", "markdown": "Find Simulink Real-Time Support For support with Speedgoat® target machines or the Speedgoat I/O Blockset, contact Speedgoat support: For support on general MATLAB® or Simulink® issues, see MathWorks® Help: For support on Simulink Real-Time™ issues, see: Simulink Real-Time Support: MathWorks Help Center website Simulink Real-Time Answers: Simulink Real-Time Central File Exchange: After searching these resources, if you still cannot solve your issue: For online or phone support, contact MathWorks technical support directly. Filter by Source Filter by Category Filter by Type Filter by Product Family xPC Target CPU Overloads xPC Target Data Logging Methodologies Disabling SMIs on Intel(R) ICH5 chipsets xPC Target Wall Time Synchronizing xPC Targets using the Parallel Port Inlining Parameters to use with xPC Target xPC Target DOSLoader Demo xPC Target Delay Timer Block xPC Target Speaker Blocks xPC target USB camera xPC Target Quick Reference Guide xPC Stand Alone Downloader xPC File Scope Tools xPC Target Function Library Quick Reference Sheet Measuring Clock Jitter with xPC Target Using the xPC Target Driver Authoring Tool to Create a Delay Timer xPC Target Driver Authoring Tool Tutorial XPC_COMMAND_CENTER NEWXPC Simulink Real-Time Target Support Package XPC_ADDBLOCKS Simulink Sleep Block for xPC Target serial send simulink block in XPC-Target with variable-size signal. serial receive simulink block in XPC-Target with variable-size signal. XPC_OPENWWWINTERFACE HIL of Position Control System XPC_DISPLAY_LOGGED_DATA NEWFCN Acoustic Singal Transmission Loss due to single or double wall Kalman Filter Application two factor CIR TID - Targeted Image Denoising TI Hercules PIL Target for RM48 Simulink (Embedded Coder) Target for TI LaunchPad Pictorial Suspicious Action Detection RTAI-Linux Target HOWTO Chinese Matlab Digest: Matlab Technical Bulletin Target Detection Image recoloring without a target image Multiple Target Tracking with Multiple Observations MIMO-SAR mmWave Imaging Toolbox Single/Multiple target Localization Statistical Digital Signal Processing and Modeling Motion Control Demo Simulink (Embedded Coder) Target for TI Stellaris LaunchPad Real-Time Workshop Targeting Tips and Scripts FMCW radar multiple moving target detection Embedded Target for Renesas RA, RL78, RX Family NEWSL Linux Soft Real-Time Target v2.4 System Target file (some info) Social Distancing Monitoring System Matlab LTspice Circuit Optimizer getTargetFromLink Intelligent Bin Picking with Simulink® for UR5e Cobot RADAR simulation TargetTracker Calculate Excel Range VU-LEGO Real Time Target Real-Time Pacer for Simulink Simulink Real-Time Support Package for ASAM XIL Standard Real-Time Blockset 7.1 for Simulink Getting Started Guide RoboNation ecal-toolbox Simulink Block for Real Time Execution Real time update of simulink variables in GUI Ball Tracking Example Soft Real Time Block for Pacing Simulink Simulations X-Plane-11-Simulink-Real-Time-Communication How to set up Elmo Gold drive with Simulink Real-Time using EtherCAT Simulink-Xplane10 Communication Via UDP RTsync Blockset 64-bit RTsync Blockset Power Electronics Templates for Simulink Real-Time Arduino Temperature Control Lab for Simulink and MATLAB Sphero Simulation in Simscape Multibody Simulink CSTR Simulation and Control Elapsed Time & Timestamp Delta Blocks for Simulink Real-Time How to Interact with Simulink Using Python Message-De-Serializer-for-ROS winaudio10 VCAPG2 extension for SIMULINK Simulink Test Support Package for ASAM XIL Standard Sphero Connectivity Package Accelerating speech prosthesis development with Simulink Pixhawk Simulink Instruments MavLink Interface Real-Time Audio Processor Microsoft Flight Simulator SITL Roll Controller Simconnect Real Time GUI for Arduino System Real-Time Beat Tracking Templates for IEEE Signal Processing Cup 2017 DAQ NI USB Simulink Block for Counter/Encoder Real Time Model Predictive Control for DC Motor Positioning Real-Time Simulation of a Hybrid-Electric Vehicle Cheatsheets for real-time simulation and testing Model Predictive Control and Estimation with Arduino Phasor Measurment Unit (Single-Phase M-Class) Process Dynamics and Control Course SimulinkEKFAttitude rtc: a pedestrian real-time clock figure STCSL - RTW version Sphero Multi-Agent Robotic Testbed for Matlab (SMART_matlab) Real-Time Emotion Recognition from USB Camera with Deep CNNs Hybrid Electric Aircraft Model in Simscape Real-Time Orbit Determination Speedgoat I/O Blockset Tutorial and Toolbox on real-time optical flow Simple EtherCAT Master for Simulink Windows Desktop Scopes for real-time display Winnov Blockset (edge and imnoise only) for Simulink Real-Time Datafeed from Yahoo! Simulink Library for Robotics Applications Real-time Magnifying Glass: An Interactive Animation Example Status Clear Source Clear Category Clear 1 xPC target toolbox 3 xPC target ASCII conversion xPC Target External error Matlab xPC target USB? xPC Target related query 2 xPC target and ARM Cortex xPC target kernel jitter xpc target xPc Target network communication Is the xPC Target C API redistributable? 0 xPC Target Animations CPU Usage in xPC Target xPC Target Logging in folders xPC Target and ABB ModbusTCP Remotely view xPC Target screen? Problem with xPC target parameter PCM-38101 xPC target deiver xPC target- multicores not boot Using intel Atom as xPC target Multithreading in single core xPC Target USB Joystick drivers for xPC Target Is it possible log an undefined amount of data with an xPC Target File Scope? xPc Target Boot Problem ? xPC Target - Device driver How to use Desktop PC as xPC Target. Writing File with xPC Target using xPC Target format R2012b xPC Target xpcexplr cannot open Can every motherboard use for xPC target application? xPC Target in Freerun mode: extra long sample time 4 xPC Target : problem with multiple NIC card TCP/IP Connection xPC Target with remote device xPC Target and B&R PowerLink (Real-Time Ethernet) Issue with building reference models with xPC target What means \"xPC\" from the xPC Target? How can I reduce the boot time for an xPC Targetbox in xPC Target 2.7.2 (R14SP2)? Is it possible to use an xPC Target Scope in a referenced model in xPC Target? Need help on xPC target with I/O card Does the xPC Target Byte Packing block from the xPC target Utilities library support back propagation? xPC Target - RS-232 Interface w/ USB-Serial Converter? Connecting to xPC Target machine takes too long time Error building xPC Target DOS Loader Is FreeDOS 9 supported for use with the xPC Target Embedded Option? xPC Target Ethernet Buffer Why do the \"To xPC Target\" and \"From xPC Target\" blocks in xPC Target 2.0.2 (R13SP1+) have the wrong number of arguments? About xPC Target and supproted IOboard Does xPC Target support force-feedback joystick as input? Regarding XPC Target Does xPC Target support the NI PCI-6224 board? How can I synchronize two xPC Target machines in xPC Target 2.0.1 (R13SP1)? Simulink Real-Time build fail Simulink Real-Time and non-Speedgoat Machine Simulink Real-Time referenced models Simulink Real-Time missing signals UDP Error Simulink Real-Time Simulink Real-Time Safety Features Simulink Real-Time USB Ethernet Simulink real-time compatible cards Simulink Real-Time with Trellix firewall Simulink Real-time CAN bus support Simulink Real-Time Host Scope Simulink Real-Time message \"System Halted\" Simulink real-time desktop kernel gone bad. Simulink Real-Time Library linux Connecting Xbox Controller to Simulink Real-Time Changing Simulink Real-Time Workspace Variable Lapack in Simulink Real-Time Desktop Simulink Real-Time runs very slow simulink real-time xpctest Test4 falied Downgrade Simulink Real-Time target support package Change update rate of Simulink Real-time Instrument Panel FAQ: Speedgoat & Simulink Real-Time (SLRT) Model Error when running simulink real-time with Speedgoat Simulink Desktop Real-Time advices Palette Pane Missing from Simulink Real-Time Error Getting Simulink Real-Time Target parameters Does Simulink Real-Time supports only desktop CPUs Simulink Real-Time Build is Not Building! Build Simulink Real-Time Applications in Parallel Simulink real-time tunable structures Simulink Real-Time with RS-232 (receiving data) Simulink Real-Time kernel bricking Windows 10 simulink real-time not useing PCI board Simulink Real-Time Host Scope in SLRT Target with Windows 7 using Simulink Real-Time Simulink Real-Time SignalTable callback syntax examples Simulink real-time setup with no target computer Why are there spikes in the Simulink Real-Time TET log? Simulink Real-time target PC ‘black screen’ problem Simulink Real-Time CPU overload in standalone mode Scope problem in Simulink Desktop Real-Time Random delays in Stream Input block in Simulink Real-Time Simulink Real-Time TCP Send variable size data input Simulink Real-Time File scope write speed Error Handling Simulink Desktop Real-Time Simulink Real-Time non-Speedgoat Machine EtherCAT PCIbus selection 6 Simulink Desktop Real-Time Kernel error: Maximum supported number of timers exceeded? control of piezo actuator in Simulink Real-Time Sample time of Host Scopes in Simulink Real-time Single use switch in Simulink Real-Time", "tags": ["Intel", "R2012B"], "tokens": 1648, "timestamp": "2025-05-03T14:44:29Z", "hash": "c2d2edce5362fabc6dcec29317327f07"}
{"url": "https://in.mathworks.com/help/slrealtime/ug_upgrade/troubleshoot-matlab-api-call-upgrade-for-r2020b.html", "title": "Troubleshoot MATLAB API Call Upgrade for R2020b", "markdown": "Troubleshoot MATLAB API Call Upgrade for R2020b In R2020b, many objects and functions in the Simulink® Real-Time™ API changed. What This Issue Means MATLAB® m-scripts written by using the Simulink Real-Time API require updates to run in R2020b and later releases. Try This Workaround These tables identify Simulink Real-Time API changes in R2020 and identify new workflows. Use these tables to guide your updates to pre-R2020b m-scripts. For information about Simulink Real-Time in previous releases, see: Target Computer Operations Real-Time Execution Operations Execution Profiler Operations Parameter Tuning Operations Signal Tracing Operations set_param(bdroot,... 'SignalLogging','on') Signal Logging Operations Instrumentation Operations Ethernet and EtherCAT Operations Target Computer Settings Operations Check model for upgradable Simulink Real-Time features Signal logging If you select Signal logging, you can use the Configure Signals to Log button to open the Signal Logging Selector. You can use the Signal Logging Selector to: Review all signals in a model hierarchy that are configured for logging. Override signal logging settings for specific signals. Control signal logging throughout a model reference hierarchy. You can use the Signal Logging Selector for both Simulink® and Stateflow® signals. For details about the Signal Logging Selector, see View Logging Configuration Using the Signal Logging Selector and Override Signal Logging Settings. For information about logging Simscape™ data, see About Simscape Data Logging (Simscape). Signal logging is not supported for: Signals inside Stateflow charts for rapid accelerator simulations Input signals of function-call subsystems, if-action subsystems, or switch case action subsystems Input signals for Merge blocks Outputs of Function-Call Generator blocks Outputs of Trigger and Enable blocks Buses inside for-each subsystems Signals in referenced models inside for-each subsystems when: The model that contains the for-each subsystem simulates in rapid accelerator mode. The for-each subsystem is inside a referenced model simulated in accelerator mode. For more information about logging signals in for-each subsystems, see Log Signals in For-Each Subsystems. State port outputs of Integrator and Discrete-Time Integrator blocks. R2023b: Log unbounded variable-size signals R2023a: Log nonvirtual buses that contain variable-size signals Nonvirtual buses that contain variable-size signals directly or in nested buses Buses with nested nonvirtual buses that contain variable-size signals Arrays of buses with nonvirtual buses that contain variable-size signals R2021a: Variable-size signal support R2019a: Signal logging parameter controls whether data streams to Simulation Data Inspector R2017a: Unified streaming and logging Topics", "tags": ["R2017A", "R2019A", "R2020B", "R2021A", "R2023A", "R2023B"], "tokens": 486, "timestamp": "2025-05-03T14:44:29Z", "hash": "8e8baf02167a1c0ecc7f3c7dea801d26"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-gaps-in-streamed-data.html", "title": "Troubleshoot Gaps in Streamed Data", "markdown": "Troubleshoot Gaps in Streamed Data A real-time application is producing a live streaming overload while attempting to stream signal data at a high rate. What This Issue Means Live streaming from a real-time application does not guarantee all the data appears in the Simulation Data Inspector. Live stream instrumentation runs at a lower priority than the real-time application. So, data sent by live streaming could be dropped if the development computer to Speedgoat® target computer connection cannot keep up. If a live stream overload occurs, you could see noticeable gaps in the data in the Simulation Data Inspector or see that some time steps are lost when you export data from the Simulation Data Inspector. Try This Workaround The issue is caused by high data rates and live streaming of data. To workaround the issue: Modify the real-time application to decrease the data rate for live streaming data. To do this, you could increase the sample rate, instrument fewer signals, or increase the decimation of instrumented signals. Change the real-time application to use file logging instead of live streaming. File logging is capable of logging higher data rates without dropping data. Log or Stream Real-Time Signals by Using the Simulation Data Inspector With the Simulation Data Inspector and Simulink® Real-Time™, you can send real-time signal data directly to the Simulation Data Inspector or by logging signal data by recording it through a File Log block. If streaming signal data directly, you view the output in real time as the application produces it. The application can produce more data than the Speedgoat® target computer can transmit in real time to the MATLAB® development computer. Data accumulates in the network buffer, and, if the buffer fills up, the RTOS drops data points. Streaming signal data directly does not support decimation or limit data points. To avoid dropped data points caused by network buffer overruns, you can use logging through a File Log block. When logging, you connect signals to File Log blocks in the model. In the real-time application, these blocks store data for the buffered signals on the target computer. At the end of execution, the real-time application transmits the data to the development computer for display in the Simulation Data Inspector. You can then view the most important signals immediately and view the buffered signals afterward. Logging signal data through a File Log block supports decimation or limit data points and supports conditional block execution semantics. Some examples are logging signal data by enabling data logging for a signal inside a for-iterator, function-call, or enabled/triggered subsystem. For more information, see Simulation Data Inspector and Real-Time Signal Logging is Affected by How Application is Run. Set Up Model for Logging To set up the model for logging signal data: Open slrt_ex_osc. Select the MuxOut output signal, place your cursor over the signal, and select Enable Data Logging. Tip Consider whether to configure the Logging sample time in the Instrumentation Properties for the logged signal. Use this property to set a lower sample time for signals that go into the Simulation Data Inspector while the simulation is running. Configuring this property can help makes the Simulation Data Inspector more responsive and easier to use. Double-click the File Log block. The Decimation value is 1. Set Up Simulation Data Inspector To set up the Simulation Data Inspector: Open the Simulation Data Inspector (). Click Layout (). Select two horizontal displays. View Simulation Data To view the simulation data: Build and download slrt_ex_osc. Start real-time execution. When the Simulation Data Inspector button glows , click the top display and select the Sum output signal. Click in the bottom display and select the Mux output signals. Stop real-time execution. When the Sum output appears, click Fit to View (). To zoom in on a time segment of interest, for example, 10.0–10.1 s, click Zoom in Time () and use the mouse and mouse wheel. To save the Simulation Data Inspector session as an MLDATX file, click Save. Real-Time Signal Logging and Parameter Tuning This example shows how to use real-time signal logging and parameter tuning with Simulink® Real-Time™. After the example builds the model and downloads the real-time application, slrt_ex_param_tuning, to the target computer, the example executes multiple runs and tunes the gain 'Gain1/Gain' parameter before each run. The gain sweeps from 0.1 to 0.7 in steps of 0.05. slrt_ex_param_tuning The example uses a Simulink Real-Time File Log block to capture signals of interest during each application run. The logged signals are uploaded to the development computer and plotted. A 3-D plot of the oscillator output versus time versus gain is displayed. Create Target Object and Connect Copy openExample Command Paste command in MATLAB to download and open example files tg = slrealtime; connect(tg); Open, Build, and Download Model to the Target Computer model = 'slrt_ex_param_tuning'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); set_param(model,'RTWVerbose','off'); set_param(model,'StopTime','0.2'); Configure for a non-Verbose build. Build and download application. evalc('slbuild(model)'); load(tg,model); Run Model, Sweep 'Gain' Parameter, Plot Logged Data Create a Simulink Real-Time target object. Set stop time to 0.2s. If no plot figure exist, create the figure. If the plot figure exist, make it the current figure. Set damping factor (Gain1/Gain). Start run of the real-time application. Store output data in outp, y, and t variables. Plot data for current run. Loop over damping factor. Create a plot of oscillator output versus time versus gain. Create 3-D plot. figh = findobj('Name', 'parsweepdemo'); if isempty(figh) figh = figure; set(figh, 'Name', 'parsweepdemo', 'NumberTitle', 'off'); else figure(figh); end y = []; flag = 0; for z = 0.1 : 0.05 : 0.7 if isempty(find(get(0, 'Children') == figh, 1)) flag = 1; break; end load(tg,model); tg.setparam([model '/Gain1'],'Gain',2 * 1000 * z); tg.start('AutoImportFileLog',true, 'ExportToBaseWorkspace', true); pause(0.4); outp = logsOut{1}.Values; y = [y,outp.Data(:,1)]; t = outp.Time; plot(t,y); set(gca, 'XLim', [t(1), t(end)], 'YLim', [-10, 10]); title(['parsweepdemo: Damping Gain = ', num2str(z)]); xlabel('Time'); ylabel('Output'); drawnow; end if ~flag delete(gca); surf(t(1 : 200), 0.1 : 0.05 : 0.7, y(1 : 200, :)'); colormap cool shading interp h = light; set(h, 'Position', [0.0125, 0.6, 10], 'Style', 'local'); lighting gouraud title('parsweepdemo: finished'); xlabel('Time'); ylabel('Damping Gain'); zlabel('Output'); end Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Close Model bdclose(model); slrtTETMonitor", "tags": ["Data"], "tokens": 1646, "timestamp": "2025-05-03T14:44:29Z", "hash": "b3a0510bd2b24b948507583235e34429"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-overloaded-cpu-from-executing-real-time-application.html", "title": "Troubleshoot Overloaded CPU from Executing Real-Time Application", "markdown": "Troubleshoot Overloaded CPU from Executing Real-Time Application Some issue is producing a CPU overload when executing a real-time application. What This Issue Means A CPU overload indicates that the CPU is unable to complete processing a model time step before restarting for the next time step. When this error occurs, the Simulink Real-Time RTOS halts model execution and the Target object property TargetStatus shows an error, for example: mCPUOverload: Sub-rate exception: Overload limit (0) exceeded in 0.02s rate with 1 overloads If you allow the overload, model execution continues until the allowed overload limit is reached. If the model continues to run after a CPU overload, the time step lasts as long as the time required to finish the execution. This behavior delays the next time step. Model design or Speedgoat® target computer resources cause CPU overloads. Possible reasons are: The target computer is too slow or the model sample time is too small. The model is too complex (algorithmic complexity). I/O latency, where each I/O channel used introduces latency into the system. I/O latency can cause the execution time to exceed the model time step. Products & Services Services Try This Workaround The Simulink® Real-Time™ RTOS usually halts model execution when it encounters a CPU overload. You can configure the Simulink Real-Time model to allow CPU overloads. Use this capability to support long initializations and for overload diagnosis. You also can try to reduce overloads by improving application performance and enabling the Compile with GCC -ffast-math option. Permit Long Initialization Time For some real-time applications, normal initialization can extend beyond the first sample time. Use the SLRT Overload Options block to increase the number of startup time steps to ignore overloads. By default, only the first time step ignores overloads. Note Allowing the target computer CPU to overload can cause incorrect results, especially for multirate models. Use the SLRT Overload Options block only for diagnosis. When your diagnosis is complete, turn off these options. Enable Compile with GCC -ffast-math Option The Compile with GCC -ffast-math option enables the GCC compiler -ffast-math option when compiling real-time application code. This option is disabled by default for Simulink Real-Time models. By enabling the Compile with GCC -ffast-math option, you provide the compiler with more flexibility to optimize floating-point math at the expense of deviating from the IEEE-754 floating-point standard. For more information about the -ffast-math option, see the Semantics of Floating-Point Math in GCC and gcc.gnu.org/wiki/FloatingPointMath/. Force Polling Mode The Force polling mode option enables polling mode — instead of interrupt-driven mode — for clocking the real-time application. Enabling this option can help reduce CPU overloads if: The target computer has at least four CPU cores. The CPU overload is caused by sporadic TET spikes. Compile with GCC -ffast-math Target Computer CPU Overload Sometimes a real-time application running on the Speedgoat® target computer does not have enough time to complete processing before the next time step. This condition is called a CPU overload. An overload is registered every time an execution step is triggered while the previous step is running. SLRT Overload Options Monitor CPU Overload Rate The SLRT Overload Options block outputs the current CPU overload count for the identified sample rate. This example shows how to design a model that uses the SLRT Overload Options block to monitor the rate at which CPU overloads occur. The rate of CPU overloads information can be useful when tuning performance of a model for which a low CPU overload rate is acceptable. Create Target Object and Connect Copy openExample Command Paste command in MATLAB to download and open example files tg = slrealtime; connect(tg); Open, Build, and Run the Model model = 'slrt_ex_overload'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); set_param(model, 'RTWVerbose', 'off'); p = get_param('slrt_ex_overload/Rate Limiter','PortHandles'); l = get_param(p.Outport,'Line'); set_param(l,'Name','Rate Limiter'); Simulink.sdi.markSignalForStreaming('slrt_ex_overload/Rate Limiter',1,'on'); evalc('slbuild(model)'); load(tg,model); start(tg); pause(20); stop(tg); Open Simulation Data Inspector Simulink.sdi.view; Examine CPU Overload Rate Data Bottom rising stair step signal -- This signal indicates the number of CPU overloads that occurred. Top rising stair step signal -- This signal indicates the number of CPU overloads that are allowed, which is (occurred + 2). Rising slew rate -- This signal indicates the rate at which CPU overloads occur. When the rising slew rate becomes greater than the top rising stair step signal, the rate of CPU overloads is greater than are allowed. Modify Rate of CPU Overloads Modify Allowed Rate of CPU Overloads Build and Run Model with Changed Overload Rates load(tg,model); tg.setparam('slrt_ex_overload/Rate Limiter','RisingSlewLimit',4); tg.setparam('slrt_ex_overload/Constant2','Value',4); start(tg); pause(20); stop(tg); bdclose(model); Webinar Automotive Industry Solutions Aerospace Industry Solutions Industrial Automation and Machinery Solutions More Industry Solutions Training Services Tailored Rack Systems Engineering Services Upcoming Events News Streamline Controller Testing & Certification for More Electric Aircrafts & eVTOLs Automotive ECU Development: Tackling R&D and Test Engineering Challenges", "tags": [], "tokens": 1109, "timestamp": "2025-05-03T14:44:29Z", "hash": "a1d9cebbd045df4c56361d2048aedda2"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-unsatisfactory-real-time-performance.html", "title": "Troubleshoot Unsatisfactory Real-Time Performance", "markdown": "Troubleshoot Unsatisfactory Real-Time Performance I want some recommended methods to improve unsatisfactory real-time application performance. What This Issue Means Run-time performance and reduce the task execution time (TET) of a model depend on model design, Speedgoat® target computer capacity, and target computer utilization. Try This Workaround You can improve run-time performance and reduce the task execution time (TET) of a model with these methods. Enable Compile with GCC -ffast-math Option The Compile with GCC -ffast-math option enables the GCC compiler -ffast-math option when compiling real-time application code. This option is disabled by default for Simulink® Real-Time™ models. By enabling the Compile with GCC -ffast-math option, you provide the compiler with more flexibility to optimize floating-point math at the expense of deviating from the IEEE-754 floating-point standard. Compile with GCC -ffast-math For more information about the -ffast-math option, see the Semantics of Floating-Point Math in GCC and gcc.gnu.org/wiki/FloatingPointMath/. Run Performance Tools Use these performance tools: To profile execution of a real-time application , use the startProfiler command. To run the profiler and plot the results, use the plot function. For more information, see Execution Profiling for Real-Time Applications. Customize Concurrent Execution on Multicore Target Computer You can improve run-time performance by configuring your model to take advantage of your multicore target computer: Partition the model into subsystems according to the physical requirements of the system that you are modeling. Set the block sample rates within each subsystem to the slowest rate that meets the physical requirements of the system. Create execution tasks and triggers, and then explicitly assign subsystem partitions to the tasks. See Partition Your Model Using Explicit Partitioning and Multicore Programming with Simulink. You can also use the Simulink Schedule Editor to partition the model. In the Simulink Editor, click the Modeling tab and select Design > Schedule Editor. For more information, see Create Partitions from a Rate-Based Model. Run the real-time application. Note Do not use MATLAB System blocks in the top level of Simulink Real-Time models in which task execution is explicitly partitioned. These blocks generate a TLC error when building the real-time application, for example: \"Unable to find TLCBlockSID within the Block scope\" Minimize the Model You can improve run-time performance by minimizing your model to make more memory and CPU cycles available for the real-time application: On the Solver pane, increase Fixed-step size (fundamental sample time). Executing with a short sample time can overload the CPU. Use polling mode. See Execution Modes for Real-Time Applications. Reduce the number of I/O channels in the model. Contact Technical Support For additional guidance, refer to these sources: MathWorks® Tech Support: MathWorks Help Center website Transformations Further floating-point related flags Note on built-in math functions Note on x86 and m68080 floating-point math Known Math Bugs Implicit use of extended precision on x86 when using the x87 FPU, see x87note -fsignaling-nans is still experimental and may not disable all optimizations that affect signaling NaN behavior. Concurrent Execution on Simulink Real-Time This example shows how to apply explicit partitioning to enhance concurrent execution of a real-time application that you generate by using Simulink® Real-Time™. Simulink Real-Time supports concurrent execution by using implicit partitioning or explicit partitioning of models. This example shows the relationship between the explicit partitioning of the tasks in the model subsystems and the execution of tasks by using the Simulink Real-Time profiling tool. Note: You can also use the Simulink® Schedule Editor to partition the model. In the Simulink Editor, click the Modeling tab and select Design > Schedule Editor. For more information, see Create Partitions from a Rate-Based Model. The example model slrt_ex_mds_and_tasks runs at sample rate of 0.001 second. To run the model with adjusted sample rate of 0.01 second, change the sample rated before running the example. In the MATLAB® Command Window, type: Ts = 0.01; Create Target Object and Connect Copy openExample Command Paste command in MATLAB to download and open example files tg = slrealtime; connect(tg); Open, Build, and Download the Model open_system('slrt_ex_mds_subsystem1'); open_system('slrt_ex_mds_subsystem2'); model = 'slrt_ex_mds_and_tasks'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); set_param(model,'RTWVerbose','off'); set_param('slrt_ex_mds_subsystem1',\"SystemTargetFile\",modelSTF); set_param('slrt_ex_mds_subsystem2',\"SystemTargetFile\",modelSTF); evalc('slbuild(model)'); load(tg,model); slrtTETMonitor; startProfiler(tg); start(tg); pause(2); stop(tg); Display Profiling Data profData = tg.getProfilerData; profData.plot; Processing data on target computer ... Transferring data from target computer ... Processing data on host computer ... View TET Information in TET monitor View TET Information in the Simulation Data Inspector See Also Generate Subsystem Code as Separate Function and Files Generate Code and Executables for Individual Subsystems Generate Inlined Subsystem Code Generate Reusable Code from Library Subsystems Shared Across Models Close the Model bdclose('slrt_ex_mds_subsystem1'); bdclose('slrt_ex_mds_subsystem2'); bdclose(model); Troubleshooting connection issues with Speedgoat target computers Why does MATLAB crash on Linux with \"Inconsistency detected by ld.so: ../elf/dl-tls.c: 597: _dl_allocate_tls_init:\" We've been listening: MATLAB R2025a Prerelease update 5 now available NumPy in MATLAB Finding the frequency value of a signal Advance Optimization Software: Fully Funded PhD with HiGHS and MathWorks at University of Edinburgh On love and research software: Sharing code with your Valentine Parallel computing in MATLAB: Have you tried ThreadPools yet? Resizing Subplots Within a Figure Calculate Amount of Cake Frosting PID Controller Simulator How to clear the MATLAB Runtime cache? how to display newline Celebrating Excellence: Recognizing MathWorks Top Accelerator Partners, India Why am I unable to access Add-Ons Explorer when my license is not current on maintenance? Find the Best Hotels Solving practical problems on quantum computers and quantum-inspired hardware with Quadratic Unconstrained Binary Optimization (QUBO) Times 2 - START HERE Convert from Fahrenheit to Celsius How to run local DeepSeek models and use them with MATLAB Find the Oldest Person in a Room Hydrogenic Wavefunction Visulization Tool The Hat, a Tridecagon Aperiordic Monotile CAD2MATDEMO.M Verify Law of Large Numbers Making a Utility to Track MATLAB Start and Stop Times How do I locate the crash dump files generated by MATLAB? Solve a System of Linear Equations Longest run of consecutive numbers plotting the frequency spectrum Code Examples from Deep Learning Ebook Mohr's Circle Convert a datetime to string Spectral and XYZ Color Functions abfload Error: \"MATLAB cannot run this file because c:\\~~~ shadows it. delete shadowing file and try again\" Downloading older versions of MATLAB Pentagonal Numbers Prompt user for a text string How to make script and command window adjacent 2nd Biennial Macroeconometric Caribbean Conference Save folder one above current directory how to concatenate string and number MatTuGames PARFOR progress monitor (progress bar) v4 Given a matrix, swap the 2nd & 3rd columns The current folder window Hydraulic decoupled suspension – the journey starts with a bold idea Convert categorical to string How to add a value beginning of an array? How to save the proceesed image in the same size as input image boost_fuzzysimulation boostcloseloop coneprog 代码生成过程中报错：'secondordercone' not supported for code generation. Better package manager abstracted away from matlab versions First order RL circuit First order RC circuit Ferranti Effect in Power Systems Why Output PWM Frequency in TMS320F28379D Controller dropping after deploying code ? Create a 2D plot with irregular axes SG F1 Starter Kit x = 1 x = 3 X = 2 y = x code Simulink and Vehicle Networks Toolbox users working in Automotive applications Managing App Closure: Control When Users Can Exit Your MATLAB App Do you use Design of Experiments (DOE) in your work with MATLAB? If so, I have a UX session... Confusing/cluttered website Accelerating Asset Management with ModelOps: From Model Building to Monitoring Can AI create better wireless chip designs than humans? How Pushing Your Code to GitHub Can Transform Your Career LLM-Enhanced Anomaly Classification for Images Roundtable Recap: Software-Defined Systems in Electrification Innovation - Key Takeaways from AI to Cybersecurity Where is MATLAB 2025a? R2025a Pre-release highlights Energy Storage System using Renewable energy Visualizing the number of blocks in a Simulink model? 4 ways of using MATLAB with Large Language Models (LLMs) such as ChatGPT and Ollama Paint store color swatch for Matlab Graph Neural Networks in MATLAB If deeply integrated with AI assistance in MATLAB Answers, what would you like it to do? R2025a Prerelease Update 5 discussion Computational-Fluid-Dynamics Grid connected PV System Grid forming droop and virtual synchronous machine. Failed to run matlab gui in Fedora 42 I found a colormap problem with Matlab 2025a Object Detection And Instance Segmentation Using YOLO v8 Remove a specific row with max value Remove a specific row with min value Remove a specific column with max value Remove a specific column with min value I recently updated my system to Fedora 42, and I am not able to launch MATLAB R2024b Ohm’s Law - Calculate Resistance Solve DAEs using IDASolve function of SUNDIALS 2.6.2 version Solving math by equal Introduction to Community Explore Community Areas Meet Community Contributors MATLAB Answers File Exchange Cody Blogs Execution Modes for Real-Time Applications The Simulink® Real-Time™ RTOS has two mutually exclusive execution modes. Interrupt mode — The scheduler implements real-time single-tasking and multitasking execution of single-rate or multirate systems, including asynchronous events (interrupts). You can interact with the Speedgoat® target computer while the real-time application is executing at high sample rates. To use this real-time mode: Leave the Force polling mode configuration parameter disabled (default). Leave the pollingThreshold application option at the default value. Polling mode — The RTOS executes real-time applications at sample times close to the limit of the CPU. Using polling mode with high-speed and low-latency I/O boards and drivers enables you to achieve real-time application sample times that you cannot achieve by using interrupt mode. Because polling mode disables interrupts on the processor core where the model runs, it imposes restrictions on the model architecture and on target communication. The base rate of the real-time application is always running when executing in polling mode. To use this real-time mode, either: Enable the Force polling mode configuration parameter. Set the pollingThreshold application option sample time value to a rate below the base rate of the model. For more information, see Force polling mode and Application. Thread Trigger | TLC Command-Line Options Create Partitions from a Rate-Based Model Create Partitions Partitioning a Model Partitions are components of a model that execute independently as atomic tasks. In multi-tasking models, partitions are created from model components. Periodic partitions are scheduled as a function of sample times in a model. In export-function models, the root function-call inputs are defined as partitions. These partitions have a schedule associated with them, which tells what order the partitions execute. With partitions, you can separate parts of the model which you can explicitly control. You can think of periodic partitions as components that run at specific rates in a model. Aperiodic partitions are components that run at specified hit times or specified events. The schedule of these partitions have an impact on simulation and code generation. The Schedule Editor enables you to partition the model and interact with those partitions. The Schedule Editor shows partitions, the connections between them, and the order of the partitions. There are three types of partitions: The blocks running at the base rate in the model is shown as an implicit partition in the Schedule Editor. The base rate is the fastest discrete rate in the model. D1 denotes the base rate. D1 annotation also appears in the Timing Legend. The D1 partition or implicit partition always remains the first discrete partition in the order. The default partitions that are already present in the model are also implicit partitions. The partition colors match their rate. Partitioning is enabled only on multitasking, fixed-step, and variable-step solver models. To choose multitasking execution mode, in Solver selection on the Solver pane, select the Type to be Fixed-step or Variable-step. Select the Treat each discrete rate as a separate task check box on the Solver pane of the Configuration Parameters dialog box. For more information on multitasking execution mode, see Time-Based Scheduling and Code Generation (Embedded Coder). Fixed-step Variable-step As a best practice, enable the Automatically handle rate transition for data transfer setting in the Solver pane. When you check Automatically handle rate transition for data transfer, Simulink inserts Rate Transition blocks between blocks when rate transitions are detected. Simulink handles rate transitions for asynchronous and periodic tasks. Simulink adds the hidden blocks configured to ensure data integrity and determinism for data transfers. When you check Treat each discrete rate as a separate task, Simulink selects multitasking execution for models operating at different rates. It also specifies that groups of blocks with the same execution priority are processed through each stage of simulation (for example, calculating output and updating states) based on task priority. To see default partitions in the Schedule Editor, open the Schedule Editor. On the Modeling tab, click Schedule Editor. Update the diagram by clicking the icon on the toolstrip. The default partitions in the model are called implicit partitions. You can also create partitions in the model through an atomic subsystem or a model block. Create Partitions Using Manage Partitions In the Schedule Editor, use the Manage Partitions panel to create partitions. To open the Manage Partitions panel, click Manage Partitions, on the Schedule Editor toolstrip. The changes made in Manage Partitions are applied to the model to create partitions after updating the diagram. Manage Partitions shows the model hierarchy with the Subsystem blocks and Model blocks which can be explicitly partitioned. To create partitions from Subsystem blocks, select the subsystems and click the . To create partitions from Model blocks, select the Model blocks and click . Enter partition names in the column Partition Name, and sample times in the column Sample Time. Repeat the steps for all the subsystems and Model blocks in the model that you want to partition. Update the diagram to see the created partitions in the Schedule Editor. The partitions appear in the graph with their deduced data dependencies and order. Creating partitions using the Manage Partitions panel makes changes to the subsystem or model block parameters. The following example shows how to configure a model for partitioning and create partitions by using Manage Partitions panel in the Schedule Editor. Open the Model Fault-Tolerant Fuel Control System example model sldemo_fuelsys. openExample('simulink_automotive/ModelingAFaultTolerantFuelControlSystemExample') sldemo_fuelsys Open the Schedule Editor. Open the Schedule Editor On the Modeling tab, click Schedule Editor. To see the default partitions, click Update Diagram in the Schedule Editor. Two implicit partitions, created automatically by Simulink, are seen in the Schedule Editor. Create partitions. Open the Manage Partitions panel. In the panel, expand the fuel_rate_control subsystem. Select the airflow_calc subsystem and click . To change the default partition name and sample time, click the default name and sample time. To create a partition for the fuel_calc subsystem, select the fuel_calc subsystem and click . The Manage Partitions panel gives you the default partition names and sample times. Update the diagram to see the newly created partitions. Create Partitions from Atomic Subsystem Blocks You can partition an atomic subsystem. An atomic subsystem is treated by Simulink as a unit when determining the execution order of block methods(partitioning is enabled only on multitasking, fixed-step and variable-step solver models). To create partitions from an atomic subsystem block, go to the Block Parameters dialog box. Select Periodic partition from the Schedule as drop-down. Give the partition a name and a discrete sample time and click OK. This creates an explicit partition for this block. To see this partition in the Schedule Editor, update the diagram. The partition appears in the graph and in the Order with the connections based on the signals in the model. Periodic partition Create Partitions from Model Blocks To create partitions from a Model block, in the Model events simulation, select Schedule rates and Schedule Editor from the Schedule rates with drop-down. When you enable partitioning from a referenced model, partitions are created from all the Model blocks present in the referenced model. These partitions are scoped by the model block name. To see this partition in the Schedule Editor, update the diagram. The partitions appear in the graph and in the Order column with the connections based on the design of your model. Schedule Editor Export-Function Partitions In export-function models, partitions are created from the function calls present in the model. To create partitions from the function calls in the export-function models, reference the export-function model in a top model. Schedule the Model block using the Schedule Editor through the block parameters. Partitions are then created from the function calls and their order is determined by the Schedule Editor. Create an export-function model. Add a Model block that references the export-function model. Set the parameter to partition the export-function model. Referencing an export-function model from a Model block allows you to partition the function calls without changing the model itself. Simulink functions in an export-functions model cannot be scheduled, and do not appear as partitions in the Schedule Editor. Add a Model block to a new Simulink model. In the Model name box, enter the name of an export-function model. For example, use the export-function model created in Create Export-Function Model. To enable the use of the Schedule Editor, configure the model to be multitasking. Open the Model Configuration Parameters. In Solver selection on the Solver pane, set the Type to Fixed-step. Check the Treat each discrete rate as a separate task and Automatically handle rate transition for data transfer parameters. Click OK. The model is enabled for partitioning. Do not convert a subsystem into a model because it automatically creates Inport blocks. Add Outport blocks to the output_100ms and output_10ms ports for saving simulation data to MATLAB®. For this example, in the export-function model, set the sample time of both the function calls to -1. Add a Sine Wave block to provide data input. Set Amplitude to 2 and Sample time to 0.01. To partition the function calls of the export-function model, in the Block Parameters dialog box for the Model block, select Schedule Editor option from the Schedule Rates with drop-down menu. Open the Schedule Editor and update the diagram to see the function calls as partitions. Multicore Programming with Simulink Using the process of partitioning, mapping, and profiling in Simulink®, you can address common challenges of designing systems for concurrent execution. Partitioning enables you to designate regions of your model as tasks, independent of the details of the embedded multicore processing hardware. This independence enables you to arrange the content and hierarchy of your model to best suit the needs of your application. In a partitioned system, mapping enables you to assign partitions to processing elements in your embedded processing system. Use the Simulink mapping tool to represent and manage the details of executing threads, HDL code on FPGAs, and the work that these threads or FPGAs perform. While creating your model, you do not need to track the partitions or data transfer between them because the tool does this work. Also, you can reuse your model across multiple architectures. Profiling simulates deployment of your application under typical computational loads. It enables you to determine the partitioning and mapping for your model that gives the best performance, before you deploy to your hardware. Simulink tries to optimize the host computer performance regardless of the modeling method you use. For more information on the ways that Simulink helps you to improve performance, see Optimize Performance. Basic Workflow To deploy your model to the target. Set up your model for concurrent execution. For more information about configuring your model for concurrent execution, see Configure Your Model for Concurrent Execution. With these settings, Simulink partitions your model based on the sample time of blocks at the root level, with each sample time in your model corresponding to a partition, and all blocks of a single rate or sample time belonging to the same partition. If you want to specify how to partition your model, use explicit partitioning. With explicit partitioning, you must specify a target architecture, and then explicitly partition your model. For more information, see Specify a Target Architecture, and Partition Your Model Using Explicit Partitioning. Generate code and deploy it to your target. You can choose to deploy onto multiple targets. To build and deploy on a desktop target, see Build on Desktop. To deploy onto embedded targets using Embedded Coder®, see Deploy Generated Software (Embedded Coder). To build and deploy on a real-time target using Simulink Real-Time™, see Standalone Operation (Simulink Real-Time). To deploy onto FPGAs using HDL Coder™, see Deployment (HDL Coder). Deployment onto FPGAs is supported only for explicitly partitioned models. Optimize your design. This step is optional, and includes iterating over the design of your model and mapping to get the best performance, based on your metrics. One way to evaluate your model is to profile it and get execution times. How Simulink Helps You to Overcome Challenges in Multicore Programming Manually programming your application for concurrent execution poses challenges beyond the typical challenges with manual coding. With Simulink, you can overcome the challenges of portability across multiple architectures, efficiency of deployment for an architecture, and cyclic data dependencies between application components. For more information on these challenges, see Challenges in Multicore Programming. Portability Simulink enables you to determine the content and hierarchical needs of the modeled system without considering the target system. While creating model content, you do not need to keep track of the number of cores in your target system. Instead, you select the partitioning methods that enable you to create model content. Simulink generates code for the architecture you specify. You can select an architecture from the available supported architectures or add a custom architecture. When you change your architecture, Simulink generates only the code that needs to change for the second architecture. The new architecture reuses blocks and functions. For more information, see Supported Targets for Multicore Programming and Specify a Target Architecture. Deployment Efficiency To improve the performance of the deployed application, Simulink allows you to simulate it under typical computational loads and try multiple configurations of partitioning and mapping the application. Simulink compares the performance of each of these configurations to provide the optimal configuration for deployment. This is known as profiling. Profiling helps you to determine the optimum partition configuration before you deploy your system to the desired hardware. You can create a mapping for your application in which Simulink maps the application components across different processing nodes. You can also manually assign components to processing nodes. For any mapping, you can see the data dependencies between components and remap accordingly. You can also introduce and remove data dependencies between different components. Cyclic Data Dependency Some tasks of a system depend on the output of other tasks. The data dependency between tasks determines their processing order. Two or more partitions containing data dependencies in a cycle creates a data dependency loop, also known as an algebraic loop. Simulink does not allow algebraic loops to occur across potentially parallel partitions because of the high cost of solving the loop using parallel algorithms. In some cases, the algebraic loop is artificial. For example, you can have an artificial algebraic loop because of Model-block-based partitioning. An algebraic loop involving Model blocks is artificial if removing the use of Model partitioning eliminates the loop. You can minimize the occurrence of artificial loops. In the Configuration Parameter dialog boxes for the models involved in the algebraic loop, select Model Referencing > Minimize algebraic loop occurrences. Ensuring deterministic delay for periodic signals can also help break algebraic loops. To configure this setting, open Model Settings> Solver > Additional parameters > Configure Tasks. In the Data Transfer pane, set the default option for Periodic Signals to Ensure deterministic transfer (maximum delay). Additionally, if the model is configured for the Generic Real-Time target (grt.tlc) or the Embedded Real-Time target (ert.tlc) in the Configuration Parameters dialog box, clear the Single output/update function check box. If the algebraic loop is a true algebraic condition, you must either contain all the blocks in the loop in one Model partition, or eliminate the loop by introducing a delay element in the loop. The following examples show how to implement different types of parallelism in Simulink. These examples contain models that are partitioned and mapped to a simple architecture with one CPU and one FPGA. Partition Your Model Using Explicit Partitioning When you have a model that is configured for concurrent execution, you can add tasks, create partitions, and map individual tasks to partitions using explicit partitioning. This enables you to execute different parts of your model to different parts of your architecture. For more information, see Implicit and Explicit Partitioning of Models. Prerequisites for Explicit Partitioning To use explicit partitioning, you must meet the following prerequisites: Set up your model for concurrent execution. For more information, see Configure Your Model for Concurrent Execution. Convert all blocks at the root level of your model into one of the following types of blocks. Models that are referenced using Model blocks Subsystem blocks MATLAB® System blocks MATLAB Function blocks Stateflow® charts For more information, see Implicit and Explicit Partitioning of Models. When using referenced models, replicate the model configuration parameters of the top model to the referenced models. Consider using a single configuration reference to use for all of your referenced models. For more information, see Model Configuration Sets. Select the target architecture on which to deploy your model. For more information, see Specify a Target Architecture. Add Periodic Triggers and Tasks Add periodic tasks for components in your model that you want to execute periodically. To add aperiodic tasks whose execution is trigger based, see Add Aperiodic Triggers and Tasks. If you want to explore the effects of increasing the concurrency on your model execution, you can create additional periodic tasks in your model. In the Concurrent Execution dialog box, right-click the Periodic node and select Add task. A task node appears in the Configuration Execution hierarchy. Select the task node and enter a name and period for the task, then click Apply. The task node is renamed to the name you enter. Optionally, specify a color for the task. The color illustrates the block-to-task mapping. If you do not assign a color, Simulink® chooses a default color. If you enable sample time colors for your model, the software honors the setting. Click Apply as necessary. To create more periodic triggers, click the Add periodic trigger symbol. You can also create multiple periodic triggers with their own trigger sources. Periodic triggers let you represent multiple periodic interrupt sources such as multiple timers. The periodicity of the trigger is either the base rate of the tasks that the trigger schedules, or the period of the trigger. Data transfers between triggers can only be Ensure Data Integrity Only types. With blocks mapped to periodic triggers, you can only generate code for ert.tlc and grt.tlc system target files. To delete tasks and triggers, right-click them in the pane and select Delete. When the periodic tasks and trigger configurations are complete, configure the aperiodic (interrupt) tasks as necessary. If you do not need aperiodic tasks, continue to Map Blocks to Tasks, Triggers, and Nodes. Add Aperiodic Triggers and Tasks Add aperiodic tasks for components in your model whose execution is interrupt-based. To add periodic tasks whose execution is periodic, see Add Periodic Triggers and Tasks. To create an aperiodic trigger, in the Concurrent Execution dialog box, right-click the Concurrent Execution node and click the Add aperiodic trigger symbol. A node named InterruptN appears in the configuration tree hierarchy, where N is an integer. Select Interrupt. This node represents an aperiodic trigger for your system. Specify the name of the trigger and configure the aperiodic trigger source. Depending on your deployment target, choose either Posix Signal (Linux/VxWorks 6.x) or Event (Windows). For POSIX® signals, specify the signal number to use for delivering the aperiodic event. For Windows® events, specify the name of the event. Click Apply. The software services aperiodic triggers as soon as possible. If you want to process the trigger response using a task: Right-click the Interrupt node and select Add task. A new task node appears under the Interrupt node. Specify the name of the new task node. Optionally, specify a color for the task. The color illustrates the block-to-task mapping. If you do not assign a color, Simulink chooses a default color. Once you have created your tasks and triggers, map your execution components to these tasks. For more information, see Map Blocks to Tasks, Triggers, and Nodes. Tip To set up your model for aperiodic tasks, connect the function call ports of the Model blocks to Asynchronous Task Specification (Simulink Coder) blocks. Then map the Asynchronous Task Specification (Simulink Coder) blocks to aperiodic triggers. For more information regarding mapping interrupts, see Map Blocks to Tasks, Triggers, and Nodes. Map Blocks to Tasks, Triggers, and Nodes After you create the tasks and triggers, you can explicitly assign partitions to these execution elements. In the Concurrent Execution dialog box, click the Tasks and Mapping node. The Tasks and Mapping pane appears. If you add a Model block to your model, the new block appears in the table with a select task entry under it. If you want to add a task to a block, in the Name column, right-click a task under the block and select Add new entry. To assign a task for the entry, click the box in the Name column and select an entry from the list. For example, periodic tasks and an aperiodic trigger are mapped to specific blocks. The block-to-task mapping symbol appears on the top-left corner of the Model block for periodic tasks or triggers and the top-left corner of the Inport block for aperiodic tasks or triggers. If you assign a Model block to multiple tasks, multiple task symbols are displayed in the top-left corner. To display the Concurrent Execution dialog box from the block, click the block-to-task mapping symbol. System tasks allow you to perform mapping incrementally. If only one periodic trigger is present, Simulink assigns any Model blocks, subsystem blocks, or MATLAB System blocks that you have not explicitly mapped to a task, trigger, or hardware node to a task created by the system. Simulink creates at most one system task for each rate in the model. If multiple periodic triggers are created, explicitly map the Model block partitions, subsystems, or MATLAB System blocks to a task, trigger, or hardware node. Map Model block partitions that contain continuous blocks to the same periodic trigger. You can map only Model blocks to hardware nodes. Also, if you map the Model block to a hardware node and the Model block contains multiple periodic sample times, clear the Allow tasks to execute concurrently on target check box in the Solver pane of the Configuration Parameters dialog box. When the mapping is complete, simulate the model again. Execution Profiling for Real-Time Applications This example shows how you can profile the task execution time and function execution time of your real-time application that is running on the target computer. Using that information, you can then tune its performance. Profiling is especially useful if you configure your real-time application to take advantage of multicore processors on the target computer. To profile the real-time application: In the Configuration Parameters dialog box for the model, enable the collection of function execution time data during execution. Build, download, and execute the model. Start and stop the profiler. Display the profiler data. The Execution Profiler and SLRT Overload Options block use different mechanisms to measure TET and do not generate identical TET values. Configure Real-Time Application for Function Execution Profiling slrt_ex_mds_subsystem1 slrt_ex_mds_subsystem2 slrt_ex_mds_and_tasks Generate Real-Time Application Execution Profile tg = slrealtime; connect(tg); model = 'slrt_ex_mds_and_tasks'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); open_system('slrt_ex_mds_subsystem1'); set_param('slrt_ex_mds_subsystem1',\"SystemTargetFile\",modelSTF); open_system('slrt_ex_mds_subsystem2'); set_param('slrt_ex_mds_subsystem2',\"SystemTargetFile\",modelSTF); evalc('slbuild(model)'); load(tg,model); setStopTime(tg,20); startProfiler(tg); start(tg); pause(5); stopProfiler(tg); stop(tg); while 1 tmp = strcmp(tg.ProfilerStatus,'DataAvailable'); if tmp == true break end end profiler_data = getProfilerData(tg); plot(profiler_data); report(profiler_data); To display the profile data for a section of the model, in the Section column, click the Membrane button next to the task. To display the TET data for the section in Simulation Data Inspector, click the Plot time series data button. To view the section in Simulink Editor, click the link next to the Expand Tree button. To view the lines of generated code corresponding to the section, click the Expand Tree button, and then click the View Source button. bdclose(model); bdclose('slrt_ex_mds_subsystem1'); bdclose('slrt_ex_mds_subsystem2'); schedule (Embedded Coder) | report | plot | ProfilerData | stopProfiler | startProfiler | resetProfiler | getProfilerData | getAvailableProfile | deleteProfilerData plot Run Profiler and Plot Profiler Data Stop the profiler. Stop the application. Retrieve profiler data. Call plot function on the data. profiler_object — Object that contains profiler result structure TargetName — Name of Speedgoat® target computer in target computer settings. ModelInfo — Information about model on which profiler ran: ModelName — Name of real-time application. MATLABRelease — MATLAB release under which model was built. Topics startProfiler Ready status indicates that the target_object exists, no profiling data is available, and the startProfiler function has not been called. StartRequested status indicates that the target_object exists, no profiling data is available, the startProfiler function has started the profiler, and the real-time application is not loaded. Running status indicates that the target_object exists, profiling data is being collected, the startProfiler function has started the profiler, and the real-time application is loaded and running. DataAvailable status indicates that the target_object exists, profiling data is available, and the real-time application and the profiler have stopped. Profile Execution of Real-Time Application Check Profiler Status from Target Object Property Start the profiler, and then start the application. After the application stops, check the profiler status. target_object — Object that represents target computer slrealtime.Target object app_name — Real-time application name character vector | string scalar", "tags": ["R2024B", "R2025A"], "tokens": 6838, "timestamp": "2025-05-03T14:44:29Z", "hash": "f6c859e9fd584cb45146aee6835adea7"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signals-for-streaming-or-file-log-logging.html", "title": "Troubleshoot Signals for Streaming or File Logging", "markdown": "Troubleshoot Signals for Streaming or File Logging There are signals selected for streaming or connected to File Log blocks in a model that generate an error that includes the text: Unable stream signal signal_name. What This Issue Means This error message for signals selected for streaming or connected to File Log blocks could indicate that the signal has one or more of these issues: The signal is not available in application. The signal does not use globally accessible memory in application. The signal connects to a Send/MessageSend block. The signal has inherited sample time. The signal is discontiguous. Try These Workarounds The workarounds for these issues vary. Try these. Workaround for Signal Not Available Make sure that these signal types are not being logged or streamed by name in the real-time application: Virtual or bus signals (including signals from bus creator blocks and virtual blocks) Signals that Simulink optimizes away Signals of complex or multiword data types Blocks without alphanumeric names Workaround for Signal Not Global Available or Discontiguous Signal To resolve, try inserting a Signal Copy block (a Signal Conversion block in Signal Copy mode) into the signals that you want to stream. Log the copied signal output instead. If you use a Dashboard block, connect it to the output signal of the Signal Copy block. Workaround for Signal Connected to Message Block To resolve, try streaming or file logging the input signal to the Send/MessageSend block. The output of the block (a message) cannot be streamed or logged. Workaround for Signal Has Inherited Sample Time To resolve, change the signal sample time from inherited to a value. Signals with inherited sample time cannot be streamed or logged. Send Animate and Understand Sending and Receiving Messages Use a Queue Block to Manage Messages Establish Message Send and Receive Interfaces Between Software Components Connect Message Receive Interface with Simulink Functions Input Port_Enable — External enable signal scalar Dependencies Port_1 — Input signal scalar | vector | matrix Output Port_1 — Output message scalar | vector | matrix Show enable port — Display the enable port off (default) | on Programmatic Use Message Send — Create and send message C/C++ Code Generation Generate C and C++ code using Simulink® Coder™. Topics", "tags": [], "tokens": 415, "timestamp": "2025-05-03T14:44:29Z", "hash": "4c76e1d8cc0a4ac66f39a8aacbb08d34"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signal-data-logging-from-send-and-receive-blocks.html", "title": "Troubleshoot Signal Data Logging from Send and Receive Blocks", "markdown": "Troubleshoot Signal Data Logging from Send and Receive Blocks A model uses Send and Receive blocks. It would be helpful to view signal data from the message line (output of send or input of receive) in the Simulation Data Inspector. Unexpected data appears when a message line in Simulink Real-Time Explorer is selected for streaming to the Simulation Data Inspector. What This Issue Means There are some guidelines to data logging message line signals: Message line signals that are marked for logging with the Simulation Data Inspector display the data accurately in the Simulation Data Inspector. Message line signals that are connected to File Log blocks display the data accurately in the Simulation Data Inspector. Message line signals that are selected for dynamic streaming with an instrument object—either by selecting the signals in Simulink Real-Time Explorer or adding the signals by using the Application object API—do not display the data accurately in the Simulation Data Inspector or in App Designer instrument panel applications. For more information about message lines, see Animate and Understand Sending and Receiving Messages. Try This Workaround To get accurate display of message line signals in the Simulation Data Inspector, mark the signals for data logging in the model or connect the signals to File Log blocks. File Log Post-Process Real-time Signals Streamed to the Simulation Data Inspector This example shows how to use a Simulink® Real-Time™ log of signal data and the Simulation Data Inspector. Signals are logged during model execution. At the end of the run, the Simulation Data Inspector interface displays the signal. This example shows how to get the signals from the Simulation Data Inspector interface for post-processing by using MATLAB® functions. Create Target Object and Connect Copy openExample Command Paste command in MATLAB to download and open example files tg = slrealtime; connect(tg); Open, Build, and Download Model model = 'slrt_suspn_3dof'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); set_param(model,'RTWVerbose','off'); evalc('slbuild(model)'); bdclose(model); Run Model to Calculate the Vertical Vehicle Displacement load(tg,model); setparam(tg,'','Cf',125); start(tg); while ~strcmp(tg.status,'stopped') pause(5); end stop(tg); Update Parameters and Re-calculate the Vertical Vehicle Displacement load(tg,model); setparam(tg,'','Cf',2375); start(tg); while ~strcmp(tg.status,'stopped') pause(5); end stop(tg); Display Signals in Simulation Data Inspector Simulink.sdi.view Retrieve and Plot Signal Data from Simulation Data Inspector Get all the runs Get the run information Get the signal Get the signal objects Plot the signals runIds = Simulink.sdi.getAllRunIDs(); for i = 1:length(runIds) run = Simulink.sdi.getRun(runIds(i)); signalID = run.getSignalIDsByName('vertical_disp'); if ~isempty(signalID) signalObj = Simulink.sdi.getSignal(signalID); signalArray(:,i) = signalObj.Values(:,1).Data; timeValues = signalObj.Values(:,1).Time; plot(timeValues,signalArray); drawnow; end end grid on; title('Response of a 3-DoF Suspension Model'); xlabel('Time (s)'); ylabel('Vehicle vertical displacement (m)'); slrtTETMonitor | SLRT Overload Options Animate and Understand Sending and Receiving Messages This example shows how to send, receive, and visualize messages. The example also shows how to use Simulation Data Inspector, Sequence Viewer, Animation, and Storage Inspector to understand how messages flow in your model. Model Description Sine Wave — The signal source. The Sample time parameter of the block is set to 0.1. Send — Converts data signals and send messages. The specified value for the Sample time parameter of the Sine Wave block determines the rate at which the Send block sends messages. Therefore, the Send block sends one message every 0.1 simulation time. Queue — Stores messages. Observe the message line between the Send block and the Queue block. The default capacity of the queue is 16, which means the Queue block can store at most 16 messages. The default message sorting behavior is LIFO, which means incoming messages are sorted based on last-in-first-out policy. By default, the Overwrite the oldest element if queue is full check box is selected. When the queue is full, an incoming message overwrites the oldest message in the queue. For more information about using the Queue block, see Use a Queue Block to Manage Messages. Receive — Receives messages and converts them to signal data. In the block, Sample time parameter is set to 0.1. The Receive block receives a message every 0.1 simulation time. Scope — Visualizes messages received by the Receive block. Simulate the Model and Review Results The Sine Wave block generates the sine wave signal (green). Every 0.1 simulation time, Send block converts the value of the signal to a message and sends it to the Queue block. Simulation Data inspector displays messages as stem plots. Observe the Simulation Data Inspector displaying sent messages (purple). The Queue block sends messages to the Receive block (blue). Receive block output is the reconstructed sine wave signal (orange). Use Sequence Viewer to Visualize Messages To activate logging events, in the Simulink Toolstrip, on the Simulation tab, in the Prepare section, click Log Events. Simulate your model. To open the Sequence Viewer tool, on the Simulation tab, in the Review Results section, click Sequence Viewer. Use Animation and Storage Inspector Display Message Payload Using Port Value Labels open_system('SimpleMessagesPortValueModel'); Sine Wave | Send | Receive | Queue | Hit Crossing Probe | Sequence Viewer Application application_name — Name of real-time application (character vector or string scalar). For example, 'slrt_ex_osc_inport'. This argument is the file name without the .mldatx file extension of the MLDATX file that the build produces on the development computer. app_object — Represent real-time application files on the development computer. This argument provides access to methods that manipulate the real-time application files. ApplicationName — Name of real-time application character vector | string scalar ModelName — Name of Simulink model character vector | string scalar UserData — User data to be add to real-time application [] (default) | character vector | numeric vector | cell array Options — Real-time application options character vector | string scalar fileLogMaxRuns selects the number of simulation runs that are stored for the real-time application when file logging is enabled. loglevel selects the log message level for the target computer system log. The available levels are error, warning, info, debug, and trace. overrideBaseRatePeriod selects an override value for the application base rate period. pollingThreshold selects the sample rate below which the RTOS thread scheduler switches polling mode, instead of interrupt-driven mode, for clocking the real-time application. Polling mode can be useful for reducing sample time jitter. But, enabling this option causes the real-time application to consume a CPU core completely to clock and execute the base rate. startupParameterSet indicates the start up parameter set from the ParameterSet objects that have been added to the Application object. To change the selection, use the updateStartupParameterSet function. stoptime selects the stop time for the real-time application. Extract ASAP2 File Create an application object for the real-time application. Retrieve the ASAP2 file from the real-time application. Update Root-Level Inport Data Change inport waveform data from a square wave to sine wave. Create an application object. Update the inport data. Download the updated inport data to the default target computer. Get and Set Application Options View application options by getting the application Options property values. Change the application stop time value option. Note You can inadvertently delete existing file logs for an installed real-time application on the target computer if you use the slrealtime.Application function to change the Options for FileLogMaxRuns and then reload the application. To change the number of stored logs without deleting existing logs, load the real-time application and then change the FileLogMaxRuns option by using the start(tg) function. Save application options to a MATLAB variable. Apply options from the variable to the real-time application by using the load function. Get Application Signals and Parameters Get the application Signals values as structures in an array. View application signals as array elements. Get the application Parameters values as structures in an array. View application parameters as array elements. R2022b: Added Application Parameter Set Options and Auto Save Topics Real-Time Signal Logging and Parameter Tuning Tune Decimation for File Log Data Without Model Rebuild Input S — Signal data for file log scalar | vector | matrix | array | bus | nonvirtual bus Decimation — Applies decimation to file log data 1 (default) | integer getAllFileLogBlocks getFileLogDecimation setFileLogDecimation Programmatic Use Input Processing — Selects processing mode for file log data Elements as channels (sample based) (default) | Columns as channels (frame based) C/C++ Code Generation Generate C and C++ code using Simulink® Coder™. R2022a: Decimation, Log Retention, and Frame-Based Input", "tags": ["R2022A", "R2022B", "Values"], "tokens": 1835, "timestamp": "2025-05-03T14:44:29Z", "hash": "1be84dc1709cce16b4bc3efa85e01696"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signal-data-logging-from-inport-ref-mode-test-harness.html", "title": "Troubleshoot Signal Data Logging from Inport in Referenced Model in Test Harness", "markdown": "Troubleshoot Signal Data Logging from Inport in Referenced Model in Test Harness A Simulink® Test™ test harness is available for a Simulink Real-Time™ model. The model has a referenced model that contains an inport whose signal are marked for data logging in the Simulation Data Inspector. During testing, this error occurs: Warning: Streaming to the SDI is not available for signal at <sldiag objui=\"outport\" objparam=\"1\" objname=\"{'Example_Harness1/Example', 'Example/Input'}\">output port 1</sldiag> of block '{'Example_Harness1/Example', 'Example/Input'}'. Add a SignalCopy block at that port and instrument the SignalCopy output port. What This Issue Means It is not possible to stream signal data from the referenced model inport for logging from within the test harness. Try This Workaround Mark the input signals to the model block for logging. This model provides an example workaround. For more information, see the Simulink Test documentation. Test Real-Time Application in Simulink Test This example shows how to perform a frequency-response test of the model slrt_ex_osc_sltest. slrt_ex_osc_sltest Using this information, in the design phase, you can modify the internal parameters of the model to meet your frequency requirements. In the production phase, you can bin manufactured parts based on frequency response. Open the Model Copy openExample Command Paste command in MATLAB to download and open example files model = 'slrt_ex_osc_sltest'; open_system(model); Step 1. Create Frequency Parameter Open model explorer. Create a Simulink® parameter Frequency in model workspace for model slrt_ex_osc_sltest. Mark the parameter as a model argument. Enter a default Value of 1. Change the Storage Class to be Model Default. Open the Signal Generator block parameters and change the Frequency parameter to be the new Simulink parameter Frequency. Step 2. Create Test Harness On the Simulink Apps tab, click Simulink Test. On the Test tab, click Add Test Harness. The software creates a Test Harness with the default name slrt_ex_osc_sltest_Harness1. In the Basic Properties tab, for the Input to Component under Test, select None. For the Output from Component under Test, select Outport. Select the Add separate assessment block check box. Select the Open harness after creation check box. Take the defaults in the remaining tabs. In Simulink Editor, on the Test tab, click Manage Test Harnesses. Click slrt_ex_osc_sltest_Harness1. Step 3. Configure Test Harness Open the Test Assessment block. To simplify the Test Assessment configuration, in the Input symbol list, delete the existing input Outport and add inputs Int1 and SigGen. Open the Block Parameters for the Test Assessment block and change the Show port labels option to FromPortIcon. This will show the input symbol names next to the port icon of the block. In slrt_ex_osc_sltest_Harness1, connect a Demux block to the signal named Out. In the Demux block dialog box, set Number of outputs to 2. Connect the top Demux block output to Test Assessment/Int1 and the bottom output to Test Assessment/SigGen. Step 4. Configure Simulink Parameters Open the Model Explorer. On the Modeling tab, pull down the Design section and click Model Explorer. In the toolbar, click the Add Simulink Parameter button. Add the following Simulink.Parameter object: Name — Criterion Value — 0 DataType — double Storage Class — ExportedGlobal Step 5. Setup Frequency Argument Right click on slrt_ex_osc_sltest_Harness1/slrt_ex_osc_sltest. Select Block Parameter(Model reference). Select Instance parameters on pop out window. Mark Frequency as an argument. Step 6. Prepare Test Assessment Steps Criterion w_open w_close HiCheck when ((et >= w_open) && (et <= w_close)) verify((abs(Int1) >= abs(SigGen) * (1.0 - Criterion)) && ... (abs(Int1) <= abs(SigGen) * (1.0 + Criterion))); Lo when (SigGen < 0) LoCheck when ((et >= w_open) && (et <= w_close)) verify((abs(Int1) >= abs(SigGen) * (1.0 - Criterion)) && ... (abs(Int1) <= abs(SigGen) * (1.0 + Criterion))); Step 7. Initialize Test Suite Open the slrt_ex_osc_sltest_Harness1 Test Harness if not already open. Then, click on the slrt_ex_osc_sltest subsystem. On the Harness tab, click Simulink Test Manager. Name the Test File realtimetest. Right-click on the existing Test Suite and click Delete to remove the example Test File contents. Right-click the Test File and select New > Real-Time Test. In the new real-time test dialog box, enter Simulation in the Test Type field. Click Create. Rename the new Test Case to frequencysweep. Rename the new Test Suite to realtimesuite. Step 8. Initialize System Under Test In the Simulink Test Manager, select Test Case frequencysweep. Select tab System Under Test. Set Model to slrt_ex_osc_sltest. Expand the Test Harness tab, set Harness to slrt_ex_osc_sltest_Harness1. Expand the Simulation Settings Overrides tab, select the Stop Time check box. Take the defaults for the other fields. Step 9. Initialize Parameter Overrides Step 10. Create Scripted Iterations cStartFreq = 15.0 Start frequency of parameter sweep. cStopFreq = 25.0 End frequency of parameter sweep. cFreqIncr = 1.0 Frequency increment. cWOpen = 0.90 Start of time window for evaluating criterion. cWClose = 0.99 End of time window for evaluating criterion. cCriterion = 0.025 Maximum normalized amplitude difference between Signal Generator and Integrator1 within the time window. vfreq Frequency at each iteration. vw_open Window opens once in each half-period. vw_close Window closes once in each half-period. In the text box, enter the following code. To resize the Scripted Iterations text box, click and drag the lower-right corner of the box. % Initialize constants cStartFreq = 15.0; cStopFreq = 25.0; cFreqIncr = 1.0; cWOpen = 0.90; cWClose = 0.99; cCriterion = 0.025; % Loop through test frequencies for vfreq = cStartFreq:cFreqIncr:cStopFreq % Create a new iteration testItr = sltest.testmanager.TestIteration(); % Calculate the time window half_period = 0.5 * (1.0/vfreq); vw_open = half_period * cWOpen; vw_close = half_period * cWClose; % Set the parameters for the iteration testItr.setVariable('Name','Frequency','Source', ... 'slrt_ex_osc_sltest','Value',vfreq); testItr.setVariable('Name','w_open','Source', ... '','Value', vw_open); testItr.setVariable('Name','w_close','Source', ... '','Value', vw_close); testItr.setVariable('Name','Criterion','Source', ... '','Value', cCriterion); % Name and add the iteration to the testcase str = sprintf('%.0f Hz', vfreq); addIteration(sltest_testCase, testItr, str); end Step 11. Run Test Connect to your target computer. Build and download real-time application slrt_ex_osc_sltest to the target computer. In the Simulink Test Manager, click the Run button with the Test Case selected. To view test results, in the left column, click Results and Artifacts. In this case, the test failed at iteration 23 Hz. To view the failing results, open nodes 23 Hz > Verify Statements and 23 Hz > Sim Output (slrt_ex_osc_sltest). Step 12. Display Results In the Data Inspector tab, select the Subplots button. Select a 2x1 grid configuration. In the Simulation Data Inspector top display, select the two Out check boxes and the top Test Assessment check box. This assessment corresponds to the HiCheck substep. In the bottom display, select the two Out check boxes and the bottom Test Assessment check box. This assessment corresponds to the LoCheck substep. Click the Zoom in Time button and select the range 4.00-4.1. Test Assessment (Simulink Test) | Test Sequence (Simulink Test)", "tags": ["Parameter", "TestIteration"], "tokens": 1598, "timestamp": "2025-05-03T14:44:29Z", "hash": "ac0dc552407dc206b80d65d69e8aeef0"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signal-data-logging-from-inport-ref-model.html", "title": "Troubleshoot Signal Data Logging from Inport in Referenced Model", "markdown": "Troubleshoot Signal Data Logging from Inport in Referenced Model A model contains referenced models. The referenced models have root-inport signals that would be helpful to log and stream to the Simulation Data Inspector for visualization. When these signals are marked in the model for logging, a warning occurs in the diagnostic viewer when building the model: Warning: Streaming to the SDI is not available for signal at <sldiag objui=\"outport\" objparam=\"1\" objname=\"{'A/B', 'B/b1'}\">output port 1</sldiag> of block '{'A/B', 'B/b1'}'. Add a SignalCopy block at that port and instrument the SignalCopy output port. What This Issue Means The warning message reports that the root-inport signals of referenced models are not available for streaming. Within top model A, the referenced model root inports that generate this warning message appear in referenced model A/B and referenced model A/B/C. Top Model A Referenced Model A/B Referenced Model A/B/C Try This Workaround To instrument a root-inport signal in a referenced model and stream the signal to the Simulation Data Inspector, you can connect the signal to a Signal Conversion block that you configure as a Signal Copy block. Mark the output of the Signal Copy block for logging to the Simulation Data Inspector. Real-Time Signal Logging and Streaming Basics Simulink® Real-Time™ signal logging with a File Log block or signal streaming from a real-time application differs from non-real-time Signal logging in Simulink. The differences include: Real-time file logging of signals acquires signal data during a real-time application run and stores it on the Speedgoat® target computer. After the real-time application stops writing to the log file, the signal data can be transferred from the target computer to the development computer for analysis. You can plot and analyze the data, and later save it to a disk on the MATLAB® development computer. Real-time signal streaming uses an instrument that you add to the real-time application. You add signals to the instrument by using selections from the Real-Time tab in the Simulink Editor, by selecting signals for streaming in the Simulink Real-Time Explorer, by marking signals for logging, or by adding other signal viewers such as a Scope block. The streaming signal data is transferred from the target computer to the development computer while the real-time application is running. This graphic shows the signal data flow for visualizing signals by using real-time signal logging and streaming. Retain Real-Time Signal Data for Post-Processing You can visualize and analyze real-time signal data in the Simulation Data Inspector after running the real-time application. To select these signals in the model before building the real-time application: Mark signals for logging to the Simulation Data Inspector. The streamed signal data for these signals is visible while the real-time application is running and available in the Simulation Data Inspector after the real-time application stops. Connect signals to File Log blocks for logging to a file on the target computer. After the real-time application stops writing the log file, the signal data is imported into the Simulation Data Inspector. With regards to file logging: Real-time signal logging to a log file samples at the base sample time by default. You can observe signals that are present in the real-time application. Some signals are not observable. Simulink Real-Time Explorer works with multidimensional signals in column-major format. Display Real-Time Signal Data without Retaining for Post-Processing Most types of signal streaming permit viewing signal data only during a real-time application run on the target computer. For these run-time-only viewers, signal streaming can use a viewer that you add to the model before building the real-time application, use an instrument that you add to the real-time application, or use a viewer—such as an App Designer instrument panel—that connects to the real-time application. Types of run-time-only signal viewers include: Adding a Scope block or other viewer to the model for viewing signals in a Scope window during external mode simulation with the model connected to the real-time application. Adding signals to an instrument in the real-time application by using selections from the Real-Time tab in the Simulink Editor or by selecting signals for streaming in the Simulink Real-Time Explorer. You can view these signals in the Simulation Data Inspector or on an Axes tab in the Simulink Real-Time Explorer. Connecting signals to an Axes component or other viewer in an App Designer instrument panel for viewing signals in the app while the real-time application runs. Real-Time Signal Logging is Affected by How Application is Run The Run on Target button provides slightly different data logging support than running the real-time application by using the start(tg) function: start (tg) When you run the real-time application by using the start(tg) function, only signals marked for signal logging or connected to a File Log block are logged to the Simulation Data Inspector. When you run the real-time application by using the Run on Target button on the real-time tab in the Simulink Editor or the Start button in the Simulink Real-Time Explorer, signals marked for logging, signals connected to File Log blocks, and signals connected to Scope blocks are logged to the Simulation Data Inspector. Signal Triggering for External Mode Simulation When setting up signal triggering (Source set to signal), explicitly specify the element number of the signal in the Trigger signal:Element box. If the signal is a scalar, enter a value of 1. If the signal is a wide signal, enter a value from 1 to 10. When uploading Simulink Real-Time signals to Simulink scopes, do not enter Last or Any in this box. 1 10 Last Any The Direction:Holdoff value does not affect the Simulink Real-Time signal uploading feature. For more information about external mode, see Simulink External Mode Interface. File Log | Enable File Log | import | start | stop | startRecording | stopRecording", "tags": [], "tokens": 1205, "timestamp": "2025-05-03T14:44:29Z", "hash": "441d4ec3c8697c9899f88786285b4eff"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signal-data-logging-from-nonvirtual-bus-fixed-point-and-multidimensional-signals.html", "title": "Troubleshoot Signal Data Logging from Nonvirtual Bus, Fixed-Point, and Multidimensional Signals", "markdown": "Troubleshoot Signal Data Logging from Nonvirtual Bus, Fixed-Point, and Multidimensional Signals Some models use signals in nonvirtual buses, signals with fixed-point data types, and multidimensional signals that have a number of dimensions greater than two. It would be helpful to view signal data from these signals in the Simulation Data Inspector. The data for these signals is not visible when they are selected in Simulink Real-Time Explorer for streaming to the Simulation Data Inspector. What This Issue Means There are some guidelines to data logging signals in nonvirtual buses, signals with fixed-point data types, and multidimensional signals that have a number of dimensions greater than two: When these signals are marked for logging with the Simulation Data Inspector, the signal data displays in the Simulation Data Inspector. When these signals are connected to File Log blocks, the signal data displays in the Simulation Data Inspector. When these signals are selected for dynamic streaming with an instrument object—either by selecting the signals in Simulink Real-Time Explorer or adding the signals by using the Application object API, the signal data does not display in the Simulation Data Inspector or in App Designer instrument panel applications. Try This Workaround There are workarounds to get signals in nonvirtual buses, signals with fixed-point data types, and mutidimensional signals (that have a number of dimensions greater than two) to display in the Simulation Data Inspector. Signals in Nonvirtual Buses To get signals in nonvirtual buses to display in the Simulation Data Inspector, mark the signals for data logging in the model or connect the signals to File Log blocks. To instrument signals in nonvirtual buses to stream to an Instrument object, use the BusElement argument in the addSignal, connectLine, or connectScalar methods. Signals with Fixed-Point Data Types To get signals with fixed-point data types to display in the Simulation Data Inspector, mark the signals for data logging in the model or connect the signals to File Log blocks. Multidimensional Signal To get signals in multidimensional signals (that have a number of dimensions greater than two) to display in the Simulation Data Inspector, mark the signals for data logging in the model or connect the signals to File Log blocks. Bus Creator | fixdt | addSignal | connectLine | connectScalar Variable-Size Signal Basics A Simulink® signal can be a scalar, vector (1-D), matrix (2-D), or N-D. A Simulink variable-size signal is a signal whose size (the number of elements in a dimension), in addition to its values, can change during a model simulation. However, during a simulation, the number of dimensions cannot change. This capability allows you to model systems with varying resources, constraints, and environments. You can create variable-size signals in your Simulink model by using: Switch or Multiport Switch blocks with different input ports having fixed-size signals with different sizes. The output is a variable-size signal. A Selector block with the Starting and ending indices (port) indexing option. The index port signal can specify different subregions of the input data signal which produce an output signal of variable size as the simulation progresses. An S-Function block with the output port configured for a variable-size signal. The output includes not only the values but also the dimension of the signal. A MATLAB Function block with the output configured for a variable-size signal. How Variable-Size Signals Propagate In the Simulink environment, variable-size signals can change their size during model execution in one of two ways: At every step of model execution Various blocks in the model modify the sizes of the signals during execution of the output method. Only during initialization of conditionally executed subsystems Size changes occur during distinct mode-switching events in subsystems such as action, enable, and function-call subsystems. You can see the key difference by considering a Discrete 2-Tap Filter block with states. Discrete 2-Tap Filter Assume that the input signal dimension to this filter changes from 4 to 1 during simulation. It is ambiguous when and how the states of the Unit Delay blocks should adapt from 4 to 1 to continue processing the input. To ensure consistency, both Unit Delay blocks must change their state behavior synchronously. To prevent ambiguity, Simulink generally disallows blocks whose number of states depends on input signal sizes in contexts where signal sizes change at any point during execution. In contrast, consider the same Discrete 2-Tap Filter block in a function-call subsystem. Assume that this subsystem is using the second way to propagate variable-size signals. In this case, the size of the input signal changes from 4 to 1 only at the initialization of the subsystem. At initialization, the subsystem resets all of its states (including the states of the two Unit Delay blocks) to their initial values. Resetting the subsystem ensures no ambiguity on the assignment of states to the input signal of the filter. Mode-Dependent Variable-Size Signals shows how you can use the two ways of propagating variable-size signals in a complementary fashion to model complex systems. Determine Whether Signal Line Has Variable Size The following example demonstrates how to use commands at the command prompt or in a script to determine whether a signal line has a variable size. In a large model or hierarchy of subsystems or referenced models, use this technique to determine whether a signal has a variable size due to an upstream block. The example model sldemo_varsize_basic contains a signal a that is downstream of a Switch block. Open the example model. Select the Sum block whose output signal is labeled a. Type the following at the command window to set the model to a compiled state (similar to a diagram update). sldemo_varsize_basic([],[],[],'compile') Get a handle to the block output port. portHandles = get_param(gcb,'portHandles'); outPortHandle = portHandles.Outport; Query the programmatic parameter CompiledPortDimensionsMode of the output port. varSize = get_param(outPortHandle,'CompiledPortDimensionsMode') varSize = 1 The value of the variable varSize is 1, which indicates that the signal a has variable size. The value 0 indicates that a signal does not have variable size. Terminate the model compilation. sldemo_varsize_basic([],[],[],'term') Empty Signals An empty signal is a signal with a length of 0. For example, signals with size [0], [0x3], [2x0], and [2x0x3] are all empty signals. Simulink allows empty signals with variable-size signals and supports most element-wise operations. However, Simulink does not support empty signals for blocks that modify signal dimensions. Unsupported blocks include Reshape, Permute, and Sum along a specified dimension. 0 [0] [0x3] [2x0] [2x0x3] Simulink Block Support for Variable-Size Signals The Simulink Block Data Type Support table includes a complete list of blocks that support variable-size signals. To view the table: Open a Simulink model. In the MATLAB® command line, enter showblockdatatypetable. A separate window with the Simulink Block Data Type Support table opens. An X in the Variable-Size Support column indicates support for that block. Tip You can also view the table by entering showblockdatatypetable at the command prompt. Subsystem Initialization of Variable-Size Signals The initial signal size from an Outport block in a conditionally executed subsystem varies depending on the parameters you select. If you set the Propagate sizes of variable-size signals parameter in the parent subsystem to During execution, the Initial output parameter for the Output block must not exceed the maximum size of the input port. If the Initial output parameter value is: If you set the Propagate sizes of variable-size signals parameter in the parent subsystem to Only when enabling, the Initial output parameter for the Output block must be a scalar value. When size is repropagated for the input of the Outport block, the initial output value is set using scalar expansion from the scalar parameter value. If the Initial output parameter is the default value [], Simulink treats the initial output as a grounded value. If the model does not activate the parent subsystem at start time (t = 0), the current size of the subsystem output corresponding to the Outport block is set to maximum size. When its parent subsystem repropagates signal sizes, the values of the subsystem variable-size output signals are also reset to their initial output parameter values. Conditionally Executed Subsystem Blocks Control port blocks are in conditionally executed subsystems. You can set the Propagate sizes of variable-size signals parameter for these blocks to During execution, Only when execution is resumed (Action Port), and Only when enabling (Enable and Trigger or Function-Call). During execution Only when execution is resumed Only when enabling Action Port Enable Trigger — Trigger type set to function-call Switching Blocks Switching blocks support variable-size signals by allowing input signals with different sizes and propagating the size of the input signal to the output signal. You can set the Allow different data input sizes parameter for these blocks on the Signal Attributes pane to either on or off. Switch Multiport Switch Manual Switch Variable-Size Signal Limitations The following table describes variable-size signal limitations. Nonvirtual buses that contain variable-size signals directly or in nested buses Buses with nested nonvirtual buses that contain variable-size signals Signal Basics A signal is a time-varying quantity that has values at all points in time. You can specify a wide range of signal attributes, including: Signal name Data type (for example, 8-bit, 16-bit, or 32-bit integer) Numeric type (real or complex) Dimensionality (one-dimensional, two-dimensional, or multidimensional array) In Simulink®, signals are the outputs of dynamic systems represented by blocks in a Simulink diagram and by the diagram itself. The lines in a block diagram represent mathematical relationships among the signals defined by the block diagram. For example, a line connecting the output of block A to the input of block B indicates that the signal output of B depends on the signal output of A. Simulink block diagrams represent signals with lines that have an arrowhead. The source of the signal corresponds to the block that writes to the signal during evaluation of its block methods (equations). The destinations of the signal are blocks that read the signal during the evaluation of the block methods (equations). The destination of signals in a model do not necessarily represent the order of simulation of blocks in a model. The simulation order is determined by Simulink automatically. Note Simulink signals are mathematical, not physical, entities. The lines in a block diagram represent mathematical, not physical, relationships among blocks. Simulink signals do not travel along the lines that connect blocks in the same way that electrical signals travel along a wire. Block diagrams do not represent physical connections between blocks. You can create a signal by adding a source block to your model. For example, you can create a signal that varies sinusoidally with time by adding an instance of the Sine, Cosine block from the Simulink Sources library into your model. To see a list of the blocks that create signals in a model, see Sources. Alternatively, you can use the Viewers and Generators Manager to create signals in your model without using blocks. Signal Line Styles A Simulink model can include many different types of signals. As you construct a block diagram, all signal types appear as a thin, solid line. After you update the diagram or start simulation, the signals appear with the specified line styles. These signal types enable you to differentiate between different signal types. From all signal types, you can only customize the nonscalar signal type. To learn more, see Signal Types. Signal Properties You may want to specify signal properties in your model to give a name or a label to your signals, prepare data for logging, or to customize your signals in a model. Use the Property Inspector, the Model Data Editor, or the Signal Properties dialog box to specify properties for: Signal names and labels Signal logging Simulink Coder™ to use to generate code Documentation of the signal To access the signal properties in the Property Inspector, first display the Property Inspector. On the Modeling tab, under Design, click Property Inspector. When you select a signal, the properties appear in the Property Inspector. To open the Model Data Editor, on the Modeling tab, click Model Data Editor. Then, inspect the Signals tab and select a signal. To use the Signal Properties dialog box, right-click a signal and select Properties. To specify signal properties programmatically, use a function such as get_param to create a variable that holds the handle to the block output port that creates the signal line. Then, use set_param to set the programmatic parameters of the port. For example: p = get_param(gcb,'PortHandles') l = get_param(p.Outport,'Line') set_param(l,'Name','s9') You can name a signal interactively or programmatically in a model. The syntactic requirements for a signal name depend on how you use the name. The most common cases are: Do not use a less than character (<) to start a signal name. The signal name can resolve to a Simulink.Signal object. (See Simulink.Signal.) The signal name must then be a legal MATLAB® identifier. This identifier starts with an alphabetic character, followed by alphanumeric or underscore characters up to the length given by the function namelengthmax. The signal has a name so the signal can be identified and referenced by name in a data log. (See Save Signal Data Using Signal Logging.) Such a signal name can contain space and newline characters. These characters can improve readability but sometimes require special handling techniques, as described in Access Logged Signals with Spaces and Newlines in Logged Names The signal name exists only to clarify the diagram and has no computational significance. Such a signal name can contain anything and does not need special handling. The signal is an element of a bus object. Use a valid C language identifier for the signal name. Inputs to a Bus Creator block must have unique names. If there are duplicate names, the Bus Creator block appends (signal#) to all input signal names, where # is the input port index. Making every signal name a legal MATLAB identifier handles a wide range of model configurations. Unexpected requirements can require changing signal names to follow a more restrictive syntax. You can use the function isvarname to determine whether a signal name is a legal MATLAB identifier. Name a signal interactively by using one of these options: The Property Inspector tool The Model Data Editor tool The Signal Properties dialog box The signal name appears below a signal, displayed as a signal label. To name a signal programmatically, use the get_param and set_param functions on the signal. The table below summarizes how to work with signal names and labels in the Simulink Editor. Signal Display Options Displaying signal attributes in the model diagram can make the model easier to read. For example, in the Simulink Editor, on the Debug tab, use the Information Overlays menu to include in the model layout information about signal attributes, such as: Port data types Design ranges Signal dimensions Signal resolution For details, see Display Signal Attributes. You can also highlight a signal and its source or destination blocks. For details, see Highlight Signal Sources and Destinations. Store Design Attributes of Signals and States You can use block parameters and signal properties to specify signal design attributes such as data type, minimum and maximum values, physical unit, and numeric complexity. To configure states, you can use block parameters. When you use these block parameters and signal properties, you store the specifications in the model file. Alternatively, you can specify these attributes by using the properties of a Simulink.Signal or Simulink.ValueType object that you store in a workspace or data dictionary. Choose which strategy to use based on your modeling goals. To configure design attributes and code generation settings for signals by using a list that you can sort, group, and filter, consider using the Model Data Editor. For objects, you can also use the Model Explorer. To determine where to permanently store a Simulink.Signal or Simulink.ValueType object, see Determine Where to Store Variables and Objects for Simulink Models. Test Signals You can perform the following kinds of tests on signals: Minimum and Maximum Values — For many Simulink blocks, you can specify a range of valid values for the output signals. Simulink provides a diagnostic for detecting when blocks generate signals that exceed their specified ranges during simulation. For details, see Specify Signal Ranges. Connection Validation — Many Simulink blocks have limitations on the types of signals that they accept. Before simulating a model, Simulink checks all blocks to ensure that the blocks can accommodate the types of signals output by the ports to which the blocks connect and reports errors about incompatibilities. To detect signal compatibility errors before running a simulation, update the diagram. The Signal Editor block displays interchangeable groups of scenarios. Use the Signal Editor to display, create, edit, and switch interchangeable scenarios. Scenarios can help with testing a model. Fixed-Point Data in MATLAB and Simulink Fixed-Point Data in Simulink You can use the fixdt function in Simulink® to specify a fixed-point data type. The fixdt function creates a Simulink.NumericType object. fixdt Simulink.NumericType Fixed-Point Data Type and Scaling Notation Simulink data type names must be valid MATLAB® identifiers with less than 128 characters. The data type name provides information about container type, number encoding, and scaling. The following table provides a key for various symbols that appear in Simulink products to indicate the data type and scaling of a fixed-point value. If you pass this character vector to the slDataTypeAndScale function, it returns a valid fixdt data type. If you pass this character vector to the slDataTypeAndScale, it returns a valid fixdt data type. Fixed-Point Data in MATLAB To assign a fixed-point data type to a number or variable in MATLAB, use the fi (Fixed-Point Designer) constructor. The resulting fixed-point value is called a fi object. For example, the following creates fi objects a and b with attributes shown in the display, all of which we can specify when the variables are constructed. Note that when the FractionLength property is not specified, it is set automatically to \"best precision\" for the given word length, keeping the most-significant bits of the value. When the WordLength property is not specified it defaults to 16 bits. fi FractionLength WordLength a = fi(pi) a = 3.1416015625 DataTypeMode: Fixed-point: binary point scaling Signedness: Signed WordLength: 16 FractionLength: 13 b = fi(0.1) b = 0.0999984741210938 DataTypeMode: Fixed-point: binary point scaling Signedness: Signed WordLength: 16 FractionLength: 18 Read Fixed-Point Data from the Workspace Use the From Workspace block to read fixed-point data from the MATLAB workspace into a Simulink model. To do this, the data must be in structure format with a fi object in the values field. In array format, the From Workspace block only accepts real, double-precision data. values Write Fixed-Point Data to the Workspace You can write fixed-point output from a model to the MATLAB workspace via the To Workspace block in either array or structure format. Fixed-point data written by a To Workspace block to the workspace in structure format can be read back into a Simulink model in structure format by a From Workspace block. Scaled Doubles Scaled doubles are a hybrid between floating-point and fixed-point numbers. Fixed-Point Designer™ stores them as doubles with the scaling, sign, and word length information retained. For example, the storage container for a fixed-point data type sfix16_En14 is int16. The storage container of the equivalent scaled doubles data type, flts16_En14 is floating-point double. Fixed-Point Designer applies the scaling information to the stored floating-point double to obtain the real-world value. Storing the value in a double almost always eliminates overflow and precision issues. sfix16_En14 int16 flts16_En14 double Functions Create Nonvirtual Buses Within Component Create Nonvirtual Buses A nonvirtual bus is analogous to a structure in C code. Use nonvirtual buses to: Construct an array of buses. Have bus data cross MATLAB Function block or Stateflow® chart boundaries. Package bus data as structures in generated C code. Interface with external code through an S-function. Reduce the number of function arguments passed to a subcomponent in generated code. A Simulink.Bus object data type must define the bus you want to make nonvirtual. A bus becomes nonvirtual when you select a block parameter such as Output as nonvirtual bus. Making the bus nonvirtual causes simulation and code generation to apply the structure defined by the bus object. When the bus is virtual, the bus object only validates the properties of the bus. To simulate a model that contains nonvirtual buses, the referenced bus objects must be in the base workspace or a data dictionary used by the model. For more information, see Specify Bus Properties with Bus Objects. Nonvirtual buses also require all elements of the bus to have the same sample time. For more information, see Modify Sample Times for Nonvirtual Buses. The way to create nonvirtual buses differs based on the location of the bus and the block that creates the bus: Create Nonvirtual Buses at Interfaces Convert Virtual Bus to Nonvirtual Bus Create Nonvirtual Bus from MATLAB Structure To focus on fundamental steps, the examples are simple. However, buses are most useful when you have many signals to combine. You can use Bus Creator blocks to create nonvirtual buses within components. Open and compile the model named BusHierarchy, which uses Bus Creator blocks to create a hierarchy of virtual buses. To compile the model, on the Modeling tab of the Simulink® Toolstrip, click Update Model or Run. Compiling the model updates the line styles, which you can use to visually identify buses. Copy openExample Command Paste command in MATLAB to download and open example files mdl = BusHierarchy; open_system(mdl) set_param(mdl,SimulationCommand=\"Update\") To create this model, see Group Signal Lines Within Component. The virtual buses in this model are not defined by Simulink.Bus objects. To change the output of the Bus Creator blocks to nonvirtual buses, you must have bus objects that match the bus hierarchy. To create the bus objects that correspond to TopBus and NestedBus, use the Simulink.Bus.createObject function. In the MATLAB® Command Window, enter this command. Simulink.Bus.createObject(\"BusHierarchy\",\"BusHierarchy/Bus Creator1\"); This function creates the bus object that corresponds to the output bus of the specified block. If the output bus contains nested buses, the function also creates bus objects that correspond to the nested buses. In this example, the function creates two bus objects that are named after the corresponding buses, TopBus and NestedBus. To view the bus objects, open the Type Editor. In the Simulink Toolstrip, on the Modeling tab, in the Design gallery, click Type Editor. To expand an external data source or bus, click the arrow next to its name. Now that you have bus objects that correspond to the nonvirtual buses you want to create, create the nonvirtual buses. In the Simulink Editor, double-click the Bus Creator block named Bus Creator1. In the Block Parameters dialog box, set Output data type to Bus: TopBus, select the Output as nonvirtual bus check box, and click OK. TopBus is now a nonvirtual bus, while NestedBus remains a virtual bus. To identify the nonvirtual bus by line style, compile the model. Double-click the block named Bus Creator. In the Block Parameters dialog box, set Output data type to Bus: NestedBus, select the Output as nonvirtual bus check box, and click OK. NestedBus is now a nonvirtual bus. To update its line style, compile the model. If you do not save the bus objects, then you must recreate the bus objects when you reopen the model. For information on how to save the bus objects, see Specify Bus Properties with Bus Objects. To create a nonvirtual bus at an interface, connect the bus elements to Out Bus Element blocks and specify that the output bus is nonvirtual. Open the model named BusOutput, which uses three Out Bus Element blocks to create a virtual bus at the output port. To create this model, see Connect Multiple Output Signals to a Port. Nonvirtual buses require a Simulink.Bus object data type. Create the bus object that corresponds to the output bus. In the Simulink® Toolstrip, on the Modeling tab, in the Design gallery, select Type Editor. In the Type Editor, create bus objects named Interface and Sinusoidal. For each bus object, create the Simulink.BusElement objects that correspond to the elements of the buses. In Sinusoidal, create elements named Chirp and Sine. In Interface, create elements named NestedBus and Step. Specify a bus object data type for any nested buses. For NestedBus, set Data type to Bus: Sinusoidal. To output a nonvirtual bus, specify the bus object data type and bus virtuality. Open the dialog box for the port by double-clicking one of the Out Bus Element blocks. In the tree hierarchy of the dialog box, pause on OutBus. Then, click the pencil icon that appears next to OutBus. Specify the bus object data type. Set Data type to Bus: Interface. In the tree hierarchy of the dialog box, click the signal attributes that now appear next to OutBus. Specify the bus virtuality. Set Bus virtuality to nonvirtual. The output of the model is a nonvirtual bus. To see the nonvirtual bus, reference the model in another model or move the Out Bus Element blocks into a subsystem. The line styles update when you compile the model. To compile the model, on the Modeling tab of the Simulink Toolstrip, click Update Model or Run. If you do not save the bus objects, you must recreate the bus objects when you reopen the model. For information on how to save the bus objects, see Specify Bus Properties with Bus Objects. In Bus Element blocks use the Bus virtuality parameter to determine whether they inherit or define the bus virtuality. If the block defines the bus virtuality and the virtuality of the input bus does not match, compiling the model produces an error. Root Inport and Outport blocks can also create nonvirtual buses at interfaces. To specify the bus virtuality: For a root Inport block, on the Signal Attributes tab of the dialog box, select Output as nonvirtual bus. For a root Outport block, on the Signal Attributes tab of the dialog box, select Output as nonvirtual bus in parent model. You can convert a virtual bus to a nonvirtual bus anywhere within a model by using a Signal Conversion block. Open and compile the model named BusConversion, which contains a virtual bus hierarchy created by Bus Creator blocks. To compile the model, on the Modeling tab of the Simulink Toolstrip, click Update Model or Run. Compiling the model updates the line styles, which you can use to visually identify buses. To define the buses and support conversion to nonvirtual buses, the Bus Creator blocks specify Simulink.Bus object data types. To create the bus objects in the base workspace when the model is loaded, the model uses the PreLoadFcn callback. To view the callback, in the Simulink Toolstrip, on the Modeling tab, click Model Settings > Model Properties. In the Model Properties dialog box, open the Callbacks tab and select the PreLoadFcn model callback. To view the bus objects, open the Type Editor. To convert a virtual bus to a nonvirtual bus, use a To Nonvirtual Bus block, which is a preconfigured version of the Signal Conversion block that has Output set to Nonvirtual bus. In the example model: Add a To Nonvirtual Bus block to the model. Drag the To Nonvirtual Bus block onto the line between the Bus Creator block named Bus Creator1 and the Scope block. When you drag the block onto the line, the block connects to the line at both ends. Suppose the data type of the bus you want to convert is not specified by a bus object. You would need to perform these additional actions: Create the corresponding bus objects. Specify the bus object data type for the bus. For example, set the Data type parameter of the To Nonvirtual Bus block to the bus object that corresponds to the input bus. The input to the To Nonvirtual Bus block is a virtual bus, and the output is a nonvirtual bus. To see the nonvirtual bus line style, compile the model. You can use a Constant block to compactly represent a nonvirtual bus with constant-valued elements. On the Constant block, specify: A MATLAB structure for Constant value. A Simulink.Bus object as the Output data type. Constant blocks only support MATLAB structures when the output data type is a Bus object. For example, define a MATLAB structure named const_param_struct with elements named Offset, Gain, and Threshold. const_param_struct.Offset = 197; const_param_struct.Gain = 4.32; const_param_struct.Threshold = 795.68; Define the corresponding Bus object data type. Simulink.Bus.createObject(const_param_struct) The new Bus object uses the default name slBus1. Open and simulate the example model, which contains a Constant block with Constant value set to const_param_struct and Output data type set to Bus: slBus1. open_system('NonvirtualBusFromStructModel') sim('NonvirtualBusFromStructModel'); The output of the Constant block is a nonvirtual bus. Blocks Objects", "tags": [], "tokens": 5726, "timestamp": "2025-05-03T14:44:29Z", "hash": "a9c5360f57aeb997844122547257b5be"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signals-not-accessible-by-name.html", "title": "Troubleshoot Signals Not Accessible by Name", "markdown": "Troubleshoot Signals Not Accessible by Name Some signal types cannot be logged or streamed in the real-time application. What This Issue Means You cannot log or stream by name these types of signals in the real-time application: Virtual or bus signals (including signals from bus creator blocks and virtual blocks). For example, assume that you connect the output of a Mux block (a virtual block) to a Simulink® Scope block. The Scope block displays the names of the Mux input signals rather than the names of the Mux output signals. Signals that Simulink optimizes away after you set the Signal storage reuse or Block reduction configuration parameters. The output of a block that was optimized away is replaced with the corresponding input signal to the block. To access these signals, make them test points. Signals of complex or multiword data types. If a block name consists only of spaces, Simulink Real-Time™ Explorer does not display a node for signals from that block. To reference such a block: Provide an alphanumeric name for the block. Rebuild and download the model to the Speedgoat® target computer. Reconnect the MATLAB® session to the target computer. Try This Workaround Check these signal types are not being logged or streamed by name in the real-time application:: Virtual or bus signals (including signals from bus creator blocks and virtual blocks) Signals that Simulink optimizes away Signals of complex or multiword data types Blocks without alphanumeric names Gain Internationalization Issues for Simulink Real-Time Simulink® Real-Time™ inherits the internationalization support of the products that it works with: Simulink, Simulink Coder™, and Embedded Coder®. Signal and parameter names that include Unicode® characters are displayed as expected in Simulink Real-Time Explorer and at the MATLAB® command line. When you use the Simulation Data Inspector to observe signals, the non-ASCII signal names are displayed as expected. For example, assume that the signal with ID 1 appears in an English-language and a Japanese-language version of the same model. In the English-language version, the signal label is input1 and the block path is block1/block2. In the Japanese-language version, the signal label is 入力1 and the block path is ブロック1/ブロック2. Third-party code (for example, parsers for vendor configuration files) sometimes does not support cross-locale, cross-platform internationalization. For such code, you must give files and folders locale-specific names. For example, when parsing a configuration file on an English-locale machine, name the file and enclosing folder with English-locale-specific names. Block reduction Blocks that simply copy their input to their output Blocks or signals in an unused code path Understand Unused Code Paths All signal paths for a block end with a block that does not execute, such as a Terminator block, a disabled Assertion block, or an S-Function block configured for block reduction. No signal paths for the block include global signal storage downstream from the block. In the first signal path, the Gain block connects to an Outport block. The software does not reduce blocks in this signal path. In the second signal path, the Gain block connects to a Terminator block. This signal path is unused because the Terminator block does not execute. These blocks are reduced for simulation and code generation when you enable Block reduction. In the last signal path, the output of the Gain block connects to a Scope block. The Scope block does execute in simulation, so this code path is not reduced in simulation. The software generates code for this signal path only when you select MAT-file logging (Simulink Coder). Identify Reduced Blocks Topics Signal storage reuse Enable local block outputs Reuse local block outputs Eliminate superfluous local variables (Expression folding) Optimize global data access (Embedded Coder) Perform in-place updates for Assignment and Bus Assignment blocks (Embedded Coder) Reuse global block outputs (Embedded Coder) Optimize block operation order in generated code (Embedded Coder) Reuse buffers for Data Store Read and Data Store Write blocks (Embedded Coder) Reuse output buffers of Model blocks (Embedded Coder) Signal storage reuse can occur only among signals that have the same data type. Clearing this option can substantially increase the amount of memory required to simulate large models. Clear this option if you need to: Debug a C-MEX S-function Use a Floating Scope or a Floating Scope block with the Floating display option selected to inspect signals in a model that you are debugging Simulink software opens an error dialog if Signal storage reuse is enabled and you attempt to use a Floating Scope or floating Display block to display a signal whose buffer has been reused. Composite Interface Guidelines To simplify model appearance, you can group signals, messages, or conserving connections to create composite interfaces for model components and blocks. Composite interfaces reduce the number of ports on a model component and the number of lines in a block diagram. Elements of a composite interface retain their separate identities. Virtual buses meet most modeling requirements for composite interfaces, and they give you the flexibility to group different types of elements. They reduce line complexity and clutter in a block diagram and make it easier to change the interface incrementally. For example, if you must add or remove elements from a component interface, modifying a bus can be simpler than adding or removing ports. When you create a composite interface, such as a virtual bus, group lines based on their functionality. By organizing signals, messages, or connections into logical groupings, you reduce the likelihood of significant refactoring in the future. At component interfaces, use In Bus Element and Out Bus Element blocks. In Bus Element blocks let you extract bus elements by name at their point of use. Out Bus Element blocks let you build an output bus by connecting elements to multiple Out Bus Element blocks for the same output port. To enforce the composition of a bus at an interface, use a Simulink.Bus object. To implement the bus definition as a structure in generated code or to iteratively process buses in a subsystem such as a for-each subsystem, consider making the virtual buses into nonvirtual buses. Visualize Composite Interfaces Suppose you have this relatively simple model. Each component interface in this model has multiple ports, and the signal lines clutter the model. With composite interfaces, you can simplify the block diagram by reducing the number of lines. Virtual buses simplify the signal lines in the block diagram based on four different types of functionality: sensor data, system goals, control signals, and system disturbances. The components use In Bus Element and Out Bus Element blocks at their interface. For example, consider the contents of the subsystem named Controller. Each In Bus Element and Out Bus Element block has a label that displays the corresponding element, for example, sensor.x1. In this example, sensor is the name of the port, and x1 is the name of the bus element. Two In Bus Element blocks select this element to avoid a branched signal line. Define Composite Interfaces Before you create composite interfaces, consider your high-level and low-level modeling requirements. Tip To identify the boundaries, scope of data, and interface attributes of your model component, see Define Interfaces of Model Components. Nonvirtual and Virtual Blocks Simulink® blocks fall into two basic categories: nonvirtual blocks and virtual blocks. Nonvirtual blocks play an active role in the simulation of a system. If you add or remove a nonvirtual block, you change the model behavior. Virtual blocks help organize a model graphically. While they play no active role in the simulation, they can affect the execution order of other blocks. Some Simulink blocks are virtual in some circumstances and nonvirtual in others. Such blocks are called conditionally virtual blocks. The table lists Simulink virtual and conditionally virtual blocks. Scope Triggers — Set triggers to sync repeating signals and pause the display when events occur. Cursor Measurements — Measure signal values using vertical and horizontal cursors. Signal Statistics — Display the maximum, minimum, peak-to-peak difference, mean, median, and RMS values of a selected signal. Peak Finder — Find maxima, showing the x-axis values at which they occur. Bilevel Measurements — Measure transitions, overshoots, undershoots, and cycles. Simulation control — Debug models from a Scope window using Run, Step Forward, and Step Backward toolbar buttons. Multiple signals — Plot multiple signals on the same y-axis (display) using multiple input ports. Multiple y-axes (displays) — Display multiple y-axes. All the y-axes have a common time range on the x-axis. Modify parameters — Modify scope parameter values before and during a simulation. Axis autoscaling — Autoscale axes during or at the end of a simulation. Margins are drawn at the top and bottom of the axes. Display data after simulation — Scope data is saved during a simulation. If a scope is closed at the start of a simulation, when you open the scope after a simulation, the scope displays simulation results for attached input signals. Note If you have a high sample rate or long simulation time, you may run into issues with memory or system performance because the scope saves data internally. To limit the amount of data saved for scope visualization, use the Limit data points to last, Limit frames to last property. Thermal Model of a House Simulating Systems with Variable Transport Delay Phenomena Do not use scope blocks in a Library. If you place a scope block inside a library block with a locked link or in a locked library, Simulink displays an error when trying to open the scope window. To display internal data from a library block, add an output port to the library block, and then connect the port to a Scope block in your model. If you step through a model, the scope only updates when the scope block runs. This means that the time shown in the status bar may not match the model time. When connected to a constant signal, a scope block may plot a single point. The scope shows gaps in the display when the signal value is NaN. When you visualize multiple frame-based signals in the scope, some samples of signals with a frame size of 1 might not be displayed. To visualize these signals, move the signals with frame size of 1 to a separate scope. Scope displays have limitations in Rapid Accelerator mode. See Behavior of Scopes and Viewers with Rapid Accelerator Mode When the Scope is in a ForEach subsystem, the scope only displays the last index. Input Port_1 — Signal or signals to visualize scalar | vector | matrix | array | bus | nonvirtual bus Type — Continuous (sample-based) or discrete (sample-based and frame-based). Data type — Any data type that Simulink supports. See Data Types Supported by Simulink. This block accepts fixed-point input, but converts it to double for display. Dimension — Scalar, one dimensional (vector), two dimensional (matrix), or multidimensional (array). Display multiple channels within one signal depending on the dimension. See Signal Dimensions and Determine Signal Dimensions. Input Limitations When the input is a constant signal, the scope plots a single point. Bus Support Configuration Properties Open at simulation start — Specify when scope window opens off (default for Scope) | on (default for Time Scope) Programmatic Use Display the full path — Display block path on scope title bar off (default) | on Number of input ports — Number of input ports on scope block 1 (default) | integer Layout — Number and arrangement of displays 1-by-1 display (default) | an arrangement of m-by-n axes Sample time — Simulation interval between scope updates -1 (for inherited) (default) | positive real number Input processing — Channel or element signal processing Elements as channels (sample based) (default for Scope) | Columns as channels (frame based) (default for Time Scope) Elements as channels (sample based) - Process each element as a unique sample. Columns as channels (frame based) - Process signal values in a channel as a group of values from multiple time intervals. Frame-based processing is available only with discrete input signals. Maximize axes — Maximize size of plots Off (default for Scope) | Auto (default for Time Scope) | On Auto - If Title and Y-label properties are not specified, maximize all plots. On - Maximize all plots. Values in Title and Y-label are hidden. Off - Do not maximize plots. Time span — Length of x-axis to display Auto (default) | User defined | One frame period Auto — Difference between the simulation start and stop times. The block calculates the beginning and end times of the time range using the Time display offset and Time span properties. For example, if you set the Time display offset to 10 and the Time span to 20, the scope sets the time range from 10 to 30. User defined — Enter any value less than the total simulation time. One frame period — Use the frame period of the input signal to the Time Scope block. This option is only available when the Input processing parameter is set to Columns as channels (frame based). Time span overrun action — Display data beyond visible x-axis Wrap (default) | Scroll Wrap — Draw a full screen of data from left to right, clear the screen, and then restart drawing the data from the left. Scroll — Move data to the left as new data is drawn on the right. This mode is graphically intensive and can affect run-time performance. Time units — x-axis units None (default for Scope) | Metric (default for Time Scope) | Seconds Metric — Display time units based on the length of Time span. Seconds — Display time in seconds. None — Do not display time units. Time display offset — x-axis offset 0 (default) | scalar | vector Scalar — Offset all channels of an input signal by the same time value. Vector — Independently offset the channels. Time-axis labels — Display of x-axis labels Bottom Displays Only (default for Scope) | All (default for Time Scope) | None All — Display x-axis labels on all y-axes. None — Do not display labels. Selecting None also clears the Show time-axis label check box. Bottom displays only — Display x-axis label on the bottom y-axis. Dependencies Show time-axis label to on. Maximize axes to off. Show time-axis label — Display or hide x-axis labels off (default for Scope) | on (default for Time Scope) Active display — Selected display 1 (default) | positive integer Dependency Show legend — Display signal legend off (default) | on The legend only shows the first 20 signals. Any additional signals cannot be controlled from the legend. Show grid — Show internal grid lines on (default) | off Plot signals as magnitude and phase — Split display into magnitude and phase plots off (default) | on On — Display magnitude and phase plots. If the signal is real, plots the absolute value of the signal for the magnitude. The phase is 0 degrees for positive values and 180 degrees for negative values. This feature is useful for complex-valued input signals. If the input is a real-valued signal, selecting this check box returns the absolute value of the signal for the magnitude. Off — Display signal plot. If the signal is complex, plots the real and imaginary parts on the same y-axis. Y-limits (Minimum) — Minimum y-axis value -10 (default) | real scalar Y-limits (Maximum) — Maximum y-axis value 10 (default) | real scalar Y-label — Y-axis label none (default for Scope) | Amplitude (default for Time Scope) | string Limit data points to last, Limit frames to last — Limit buffered data points or frames off, 5000 (default) | on | positive integer Elements as channels (sample based) –– The scope saves the last n data points and the name of this property is Limit data points to last. n is the scalar value you specify in this property text box. Columns as channels (frame based) –– The scope saves the last n data frames and the name of this property is Limit frames to last. If you do not select this property and you have a high sample rate or long simulation time, you can run into issues with memory or system performance. Decimation, Decimate frames — Reduce amount of scope data to display and save off, 2 (default) | on | positive integer Elements as channels (sample based) –– The scope plots and logs data every Nth data point. The name of this property is Decimation. Columns as channels (frame based) ––- The scope plots and logs data every Nth frame. The name of this property is Decimate frames. Log data to workspace — Save data to MATLAB workspace off (default) | on Variable name — Name of saved data variable ScopeData (default) | string Save format — MATLAB variable format Dataset (default) | Structure With Time | Structure | Array Dataset — Save data as a Dataset object, by default a timeseries object. Structure With Time — Save data as a structure with associated time information. Structure — Save data as a structure. Array — Save data as an array with associated time information. This format does not support variable-size data. Axes Scaling Properties Axes scaling — Y-axis scaling mode Manual (default) | Auto | After N Updates Manual — Manually scale the y-axis range with the Scale Y-axis Limits toolbar button. Auto — Scale the y-axis range during and after simulation. Selecting this option displays the Do not allow Y-axis limits to shrink check box. If you want the y-axis range to increase and decrease with the maximum value of a signal, set Axes scaling to Auto and clear the Do not allow Y-axis limits to shrink check box. After N Updates — Scale y-axis after the number of time steps specified in the Number of updates text box (10 by default). Scaling occurs only once during each run. Do not allow Y-axis limits to shrink — When y-axis limits can change on (default) | off Number of updates — Number of updates before scaling 10 (default) | integer Scale axes limits at stop — When y-axis limits can change on (default) | off On — Scale axes when simulation stops. Off — Scale axes continually. Y-axis Data range (%) — Percent of y-axis to use for plotting 80 (default) | integer between [1, 100] Y-axis Align — Alignment along y-axis Center (default) | Top | Bottom Top — Align signals with the maximum values of the y-axis range. Center — Center signals between the minimum and maximum values. Bottom — Align signals with the minimum values of the y-axis range. Autoscale X-axis limits — Scale x-axis range limits off (default) | on X-axis Data range (%) — Percent of x-axis to use for plotting 100 (default) | integer in the range [1, 100] X-axis Align — Alignment along x-axis Center (default) | Left | Right Right — Align signals with the maximum values of the x-axis range. Left — Align signals with the minimum values of the x-axis range. Style Properties Figure color — Background color for window black (default) | color Plot type — How to plot signal Auto (default for Scope) | Line (default for Time Scope) | Stairs | Stem Axes colors — Background and axes color for individual displays black (default) | color Preserve colors for copy to clipboard — Copy scope without changing colors off (default) | on Properties for line — Line to change Channel 1 (default) Visible — Line visibility on (default) | off Line — Line style solid line (default style) | 0.75 (default width) | yellow (default color) Marker — Data point marker style None (default) | marker shape C/C++ Code Generation Generate C and C++ code using Simulink® Coder™. HDL Code Generation Generate VHDL, Verilog and SystemVerilog code for FPGA and ASIC designs using HDL Coder™. PLC Code Generation Generate Structured Text code using Simulink® PLC Coder™. Fixed-Point Conversion Design and simulate fixed-point systems using Fixed-Point Designer™.", "tags": [], "tokens": 4005, "timestamp": "2025-05-03T14:44:29Z", "hash": "82edb71141c2fb84757df942c56a4cf0"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-parameters-not-accessible-by-name.html", "title": "Troubleshoot Parameters Not Accessible by Name", "markdown": "Troubleshoot Parameters Not Accessible by Name Some parameters cannot be observed or tuned in the real-time application. What This Issue Means Reasons that you cannot observe or tune some parameters in the real-time application are: Simulink® Real-Time™ does not support parameters of multiword data types. During execution, you cannot tune parameters that change the model structure, for example, by adding a port. To change these parameters, you must stop the execution, change the parameter, and rebuild the real-time application. Try This Workaround Check the parameters for the issues described in What This Issue Means.", "tags": [], "tokens": 116, "timestamp": "2025-05-03T14:44:29Z", "hash": "3d2aa98620d733050c6883e1858fe93d"}
{"url": "https://in.mathworks.com/help/slrealtime/ug_upgrade/troubleshoot-s-function-build-upgrade-for-r2020b.html", "title": "Troubleshoot S-Function Build Upgrade for R2020b", "markdown": "Troubleshoot S-Function Build Upgrade for R2020b A pre-R2020b model uses S-Functions. When migrating this model to the current release, this S-Function related message appears in the build log: undefined reference to 'C function in S-Function' What This Issue Means In R2020b, the compiler for model builds changed from a Windows® compatible C compiler to the QNX® Neutrino® C++ compiler. To accommodate this change, update S-Function code for C++ compatibility. Tip Fortran S-Functions are not supported in R2020b and later releases of Simulink® Real-Time™. Try This Workaround To update S-Function code for C++ compatibility, modify the declaration of the S-Function in the header file. For example, update this C S-Function declaration: void getAllDataMyFunction(short); void myfunction_initialize(short, unsigned char*, short*); void myfunction_terminate(short, int); Updated the code to this C++ S-Function declaration: #ifdef __cplusplus extern \"C\" { #endif void getAllDataMyFunction(short); void myfunction_initialize(short, unsigned char*, short*); void myfunction_terminate(short, int); #ifdef __cplusplus } #endif Before building the updated code, remember to remove all artifacts from previous model builds. How to mix C and C++ Contents of this section: What do I need to know when mixing C and C++ code? ¶ Δ How do I call a C function from C++? ¶ Δ How do I call a C++ function from C? ¶ Δ How can I include a standard C header file in my C++ code? ¶ Δ How can I include a non-system C header file in my C++ code? ¶ Δ How can I modify my own C header files so it’s easier to #include them in C++ code? ¶ Δ How can I call a non-system C function f(int,char,float) from my C++ code? ¶ Δ How can I create a C++ function f(int,char,float) that is callable by my C code? ¶ Δ Why is the linker giving errors for C/C++ functions being called from C++/C functions? ¶ Δ How can I pass an object of a C++ class to/from a C function? ¶ Δ Can my C function directly access data in an object of a C++ class? ¶ Δ Why do I feel like I’m “further from the machine” in C++ as opposed to C? ¶ Δ External Code Integration Category Integrate existing MATLAB® code into Simulink Integrate existing C/C++ Code into Simulink Integrate existing C or C++ functions, such as device drivers or external simulation code Examine considerations for external code integration and Simulink Real-Time™ models. Control Real-Time Application by Using C# Code Run Real-Time Application by Using Python Script Hello World! Example External Code Integration for Simulink Real-Time", "tags": ["R2020B"], "tokens": 605, "timestamp": "2025-05-03T14:44:29Z", "hash": "d195adb3474a327bca909779bddbb062"}
{"url": "https://in.mathworks.com/help/slrealtime/ug_upgrade/troubleshoot-model-upgrade-to-r2020b.html", "title": "Troubleshoot Model Upgrade for R2020b", "markdown": "Troubleshoot Model Upgrade for R2020b When building a pre-R2020b Simulink Real-Time models in R2020b, build errors occur. Some of the blocks in the model have the label Obsolete Simulink Real-Time Block. What This Issue Means For R2020b, you must upgrade the Simulink Real-Time model. A model Upgrade Advisor check is available to support this upgrade. Try This Workaround To upgrade your model for Simulink Real-Time R2020b features, use this software upgrade process: Install Simulink Real-Time and other required products. Install the Simulink Real-Time Target Support Package by using the MATLAB Add-Ons menu. ​Install the Speedgoat I/O Blockset. Go to the Speedgoat website. Upgrade the target machine software. See Troubleshoot System Upgrade for R2020b. Open a R2020b or earlier Simulink Real-Time model. Run the Upgrade Advisor. On the Modeling tab, select Model Advisor > Upgrade Advisor. In the Upgrade Advisor dialog box, select Check model for upgradable Simulink Real-Time features. Click the Run This Check button. The advisor lists the upgrades that it can apply and the upgrades that require manual changes. After the check, click the Upgrade button. The advisor upgrades the model by applying all nonmanual changes. Apply Manual Changes When the Upgrade Advisor encounters model issues that it cannot resolve by using automated changes, the Upgrade Advisor reports these as Warning: Some of the features require manual changes. It is a good practice to copy the text of these warnings and save it for reference as you apply changes to your model. Apply Speedgoat Utilities In R2020b, Speedgoat® software provides support for configuring interrupts and Ethernet communications. To configure model interrupts, use a single block from the Speedgoat I/O Blockset. You can use this block for asynchronous subsystems or for triggering the base rate of the model. The list of available interrupt sources reflects the Speedgoat I/O Blockset blocks configured in the model. For more information see the block documentation in speedgoatlib_utilities. To configure additional Ethernet ports on the target machine, the Speedgoat I/O Blockset provides a tool to configure these Ethernet ports. The configuration is specific to the target machine and reflects the labeling on the front plates of the target machine. For more information, in the MATLAB Command Window, type: speedgoat.configureEthernet Troubleshoot System Upgrade for R2020b required products Training Events Learning Resources Visit the Help Center to explore product documentation, engage with community forums, check release notes, and more. MATLAB and Simulink Videos Learn about products, watch demonstrations, and explore what's new. Company Careers Decarbonizing MathWorks See how MathWorks is protecting and restoring Earth's resources. Search Supported Platforms Product Requirements Eligible for Use with MATLAB Compiler and Simulink Compiler Eligible for Use with Parallel Computing Toolbox and MATLAB Parallel Server Supported Third-Party Compilers", "tags": ["R2020B"], "tokens": 535, "timestamp": "2025-05-03T14:44:29Z", "hash": "2c26ef0c9044f17170afb74fe418ac01"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-working-with-persistent-variables.html", "title": "Troubleshoot Working with Persistent Variables", "markdown": "Troubleshoot Working with Persistent Variables When running the getPersistentVariables function or setPersistentVariables function, this error appears: Cannot parse the file that stores persistent variables from target computer. To clear the issue, delete all persistent variables on target computer. For more information, see Troubleshoot Working with Persistent Variables. What This Issue Means This error message indicates that the file on the Speedgoat® target computer that stores the persistent variable values is corrupted or unreadable. Try This Workaround To resolve this issue, clear the persistent variable values that are stored on the target computer. On the development computer, create a Target object tg and connect to the target computer. tg = slrealtime; connect(tg); Use the setPersistentVariables function to clear the persistent variable values that are stored on the target computer. setPersistentVariables(tg,[]); getPersistentVariables | setPersistentVariables | Persistent Variable Read | Persistent Variable Write Apply Persistent Variables in Real-Time Applications This example shows how to apply persistent variables in real-time applications. In a model, you save variables on target computer whose values persist when the real-time application stops and even when the target computer is shut down by using Persistent Variable Write blocks. At real-time application start, you direct the real-time application to read these persistent variables by using Persistent Variable Read blocks. In MATLAB®, you can get or set the values of persistent variables on the target computer by using the getPersistentVariables function and the setPersistentVariables function. Examine Persistent Variables in the Model Create Target Object and Connect Copy openExample Command Paste command in MATLAB to download and open example files Build Real-Time Application model = 'slrt_ex_persist'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF) Build and Load the Real-Time Application evalc('slbuild(model)'); load(tg,model); Initial Value of Persistent Variable Observe How Persistent Variable Changes in First Run start(tg); pause(5); myPersistVars = getPersistentVariables(tg) myPersistVars = struct with fields: position: 20 Observe How Persistent Variable Changes in Second Run load(tg,model); start(tg); myPersistVars = struct with fields: position: 40 Clear the Persistent Variable Values myNewPersistVars = rmfield(myPersistVars,'position'); setPersistentVariables(tg,myNewPersistVars); myPersistVars = getPersistentVariables(tg) myPersistVars = [] setPersistentVariables(tg, []); Preserve Persistent Variable Data by Safe Shutdown of Target Computer Close All Files bdclose(model); setPersistentVariables Get and Set Persistent Variables Get persistent variable values from target computer tg. Change the value of Variable1 in the myPersist structure. Add Variable1 to the structure. Set the persistent variable values on the target computer. Get the variables from the target computer. Remove Persistent Variables from Target Computer Remove a Persistent Variable from Target Computer Get the persistent variable values from the target computer. Copy the persistent variable values to a variable and remove the field for the variable. This example removes the field for the variable position. Use the setPersistentVariables function to apply the updated persistent variable values to the target computer. target_object — Object that represents target computer slrealtime.Target object variables_struct — Structure of persistent variable values struct Topics Target Start and stop the real-time application. Read and set parameters. Log and stream signals. Retrieve status information about the target computer. Restart the target computer. Load the real-time application. Start, stop, and retrieve information from the profiler. target_name — Name assigned to target computer (character vector or string scalar). For example, 'TargetPC1'. target_object — Object representing target computer. For example, tg. Create Target Object for Default Target Computer Create Target Object for Named Target Computer Build and Run Real-Time Application R2022b: Removed and Added Target Object Functions R2021b: Additional Target Object Functions", "tags": ["R2021B", "R2022B"], "tokens": 740, "timestamp": "2025-05-03T14:44:29Z", "hash": "011e40254379a116a948be453f3cb232"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-long-build-times-for-real-time-application.html", "title": "Troubleshoot Long Build Times for Real-Time Application", "markdown": "Troubleshoot Long Build Times for Real-Time Application The model build process for a Simscape™ Multibody™ models is slow and uses an unexpected amount of memory. What This Issue Means The default QNX® Neutrino® compiler switches for Simulink® Real-Time™ apply optimizations that lead to long build times or slow builds for some complex models, such as Simscape Multibody models. Try This Workaround To improve the real-time application build speed, change the compiler switch selections from the default selections by adding the -fdisable-rtl-sched2 switch for the C/C++ compiler: Open your Simulink Real-Time model. In the Simulink Editor, from the Real-Time tab, select Hardware Settings. Click the C Compiler options and add option -fdisable-rtl-sched2. Click the C++ Compiler options and add option -fdisable-rtl-sched2. Click Apply and OK. After updating the compiler options, the options appear as shown. If you prefer to use a programmatic approach to update these compiler switches, you could use this code. % add a compiler flag '-fdisable-rtl-sched2' set_param(modelName, 'BuildConfiguration', 'Specify'); options = get_param(modelName, 'CustomToolchainOptions'); ccompiler_idx = find(strcmp(options, 'C Compiler')); cppcompiler_idx = find(strcmp(options, 'C++ Compiler')); options{ccompiler_idx+1} = ... [options{ccompiler_idx+1} ' -fdisable-rtl-sched2']; options{cppcompiler_idx+1} = ... [options{cppcompiler_idx+1} ' -fdisable-rtl-sched2']; set_param(modelName, 'CustomToolchainOptions', options);", "tags": [], "tokens": 339, "timestamp": "2025-05-03T14:44:29Z", "hash": "33d915313dbcac572abc2b5b2c613327"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-build-error-for-accelerator-mode.html", "title": "Troubleshoot Build Error for Accelerator Mode", "markdown": "Troubleshoot Build Error for Accelerator Mode A build error occurs when building a model in accelerator mode or rapid accelerator mode when the model contains Simulink Real-Time blocks (for example, model blocks that represent hardware). What This Issue Means Simulink Real-Time does not support accelerator mode or rapid accelerator mode simulation of models with blocks that represent hardware. For example, open the slrt_ex_serialasciitest model. openExample('slrt_ex_serialasciitest'). Change the Simulink mode to rapid accelerator, and run the model, Simulink displays this error: Unable to build a standalone executable to simulate the model 'slrt_ex_serialasciitest' in rapid accelerator mode. This error occurs because accelerator mode and rapid accelerator mode produce compiled code that runs on the development computer, not on the Speedgoat® target computer. Any blocks that access hardware report a build error if you compile the model by using accelerator mode or rapid accelerator mode. Try This Workaround Change the simulation mode to normal mode or external mode. Simulink Real-Time Options Pane Control the code created by Simulink® Coder™ code generation software for a Simulink Real-Time™ application. Set up general information about building real-time applications, including target, execution, data logging, and other options. Configuration The Simulink Real-Time Options node in the Configuration Parameters dialog box allows you to specify how the software generates the real-time application. To reveal the Simulink Real-Time Options node, do the following: In the Code Generation pane, in the System target file list, select slrealtime.tlc or another Simulink Real-Time STF. This setting generates system target code for Simulink Real-Time. Note If you open a model that was originally saved with System target file set to xpctarget.tlc, the software updates the setting to slrealtime.tlc. To retain the updated setting, save the updated model. Tips The default values work for the generation of most real-time applications. If you want to customize the build of your real-time application, set the option parameters to suit your specifications. To access configuration parameters from the MATLAB® command line, use: gcs — To access the current model. set_param — To set the parameter value. get_param — To get the current value of the parameter. To get help on an option Right-click the option text label. From the context menu, select What's This. How Acceleration Modes Work Overview The accelerator and rapid accelerator modes use portions of the Simulink® Coder™ product to create an executable. The accelerator and rapid accelerator modes replace the interpreted code normally used in Simulink simulations, shortening model run time. Although the acceleration modes use some Simulink Coder code generation technology, you do not need the Simulink Coder software installed to accelerate your model. The code generated by the accelerator and rapid accelerator modes is suitable only for speeding the simulation of your model. Use Simulink Coder to generate code for other purposes. Normal Mode In normal mode, the MATLAB® technical computing environment is the foundation on which the Simulink software is built. Simulink controls the solver and model methods used during simulation. Model methods include such things as computation of model outputs. Normal mode runs in one process. Accelerator Mode By default, accelerator mode uses Just-in-Time (JIT) acceleration to generate an execution engine in memory instead of generating C code or MEX files. You can also have your model fall back to the classic accelerator mode, in which Simulink generates and links code into a C-MEX S-function. In accelerator mode, the model methods are separate from the Simulink software and are part of the acceleration target code, which is used in later simulations. Simulink checks that the acceleration target code is up to date before reusing it. For more information, see Code Regeneration in Accelerated Models. There are two modes of operation in accelerator mode. Just-In-Time Accelerator Mode In this default mode, Simulink generates an execution engine in memory for the top-level model only and not for referenced models. As a result, a C compiler is not required during simulation. Because the acceleration target code is in memory, it is available for reuse as long as the model is open. Simulink also serializes the acceleration target code so that the model does not need rebuilding when it is opened. Classic Accelerator Mode If you want to simulate your model using the classic, C-code generating, accelerator mode, run the following command: set_param(0,'GlobalUseClassicAccelMode','on'); In this mode, Simulink generates and links code into a shared library, which communicates with the Simulink software. The target code executes in the same process as MATLAB and Simulink. Rapid Accelerator Mode Rapid accelerator mode creates a rapid accelerator standalone executable from your model. This executable includes the solver and model methods, but it resides outside of MATLAB and Simulink. It uses external mode (see External Mode Communication (Simulink Coder)) to communicate with Simulink. MATLAB and Simulink run in one process, and if a second processing core is available, the standalone executable runs there.", "tags": [], "tokens": 976, "timestamp": "2025-05-03T14:44:29Z", "hash": "752b734718a85d19666540ebabc1b550"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-model-links-to-static-libraries-or-shared-objects.html", "title": "Troubleshoot Model Links to Static Libraries or Shared Objects", "markdown": "Troubleshoot Model Links to Static Libraries or Shared Objects Some model build and runtime issues occur when linking a real-time application to static libraries (.a) or shared objects (.so). What This Issue Means When building or running real-time an application that links to static link libraries (.a) or shared object libraries (.so), there are some considerations that help you use libraries that are compatible with the QNX® Neutrino® RTOS on the Speedgoat® target computer. These recommendations are helpful when troubleshooting library usage, including: A link to a library from QNX Neutrino RTOS that is available in the Simulink Real-Time target support package A shared object that is included in the model through an FMU block A custom static library or shared object that is linked to the real-time application Try This Workaround These workarounds explore the possible issues. Link to Accessible Libraries or Objects When you link to a static library or shared object, the library or object must be: Compatible with the QNX Neutrino RTOS Accessible to the toolchain at build time Check to ensure that you have followed the guidelines for library compatibility. See External Code Integration of Libraries and C/C++ Code with Simulink Real-Time Models. Check that the toolchain can access the library at build time. Remember that the QNX Neutrino cannot process spaces in the path to files. Install Shared Objects on Target Computer After you build the real-time application that links to a shared object, install both the real-time application and the shared object on the target computer. Copy the shared objects to a location on the target computer where they can be found and loaded at runtime. The recommended locations are /lib, /usr/lib, or /usr/local/lib. Root access is required to copy files to these locations. Rebuild Real-Time Application When Rebuilding Static Libraries Because linked static libraries are included in the real-time application, when you modify and rebuild a static library, you rebuild any real-time applications that include that library. After rebuilding the static library and the real-time application, reinstall the real-time application on the target computer. FMU Compile Source Code for Functional Mock-up Units When you build a model that includes FMU blocks, you must compile the FMU source code by using the QNX Neutrino compiler qcc or q++. This compiler creates shared object SO files that you include in the FMU. This process makes sure that the FMU contains the code to run on a Simulink Real-Time target computer. For more information, see Apply Functional Mock-up Units by Using Simulink Real-Time. Implement the FMU Block in Model Compile FMU File That Contains Source Code Copy openExample Command Paste command in MATLAB to download and open example files mkdir tempdir myFmuDir; cd tempdir; cd myFmuDir; copyfile ../../slrt_ex_fmu_work; Warning: Directory already exists. my_file = 'vanDerPol.fmu'; evalc('slrealtime.fmu.compileFMUSources(my_file,''overwriteBinary'',true)'); FMU | slrealtime.fmu.compileFMUSources Build Support for S-Functions Build Integrated Code Within the Simulink Environment Workflow To build executable programs that integrate generated code and external C or C++ code, iterate through the tasks in this table. Configure Parameters for Integrated Code Build Process The table provides a guide to model configuration parameters on Code Generation > Custom Code pane of the Model Configuration Parameters dialog box that support the build process for external code integration. For information about folders for your external code, see Manage Build Process Folders (Embedded Coder). If you choose to place your external code in the Code generation folder, see Preserve External Code Files in Build Folder (Embedded Coder). %.obj: buildir\\inc\\%.c $(CC) -c -Fo$(@F) $(CFLAGS) $< Preserve External Code Files in Build Folder By default, the build process deletes foreign source files. You can preserve foreign source files by following these guidelines. If you put a .c/.cpp or .h source file in a build folder, and you want to prevent the code generator from deleting it during the TLC code generation process, insert the text target specific file in the first line of the .c/.cpp or .h file. For example: /* COMPANY-NAME target specific file * * This file is created for use with the * COMPANY-NAME target. * It is used for ... */ ... Make sure that you spell the text “target specific file” as shown in the preceding example, and that the text is in the first line of the source file. Other text can appear before or after this text. Flagging user files in this manner prevents postprocessing these files to indent them with generated source files. Auto-indenting occurred in previous releases to build folder files with names having the pattern model_*.c/.cpp (where * was text). The indenting is harmless, but can cause differences detected by source control software that can potentially trigger unnecessary updates. User-written S-Function blocks provide a powerful way to incorporate external code into the Simulink® development environment. In most cases, you use S-functions to integrate existing external code with generated code. Several approaches to writing S-functions are available: Write Noninlined S-Function Write Wrapper S-Function and TLC Files Write Fully Inlined S-Functions Write Fully Inlined S-Functions with mdlRTW Routine S-Functions for Code Reuse S-Functions for Multirate Multitasking Environments S-functions also provide the most flexible and capable way of including build information for legacy and custom code files in the build process. There are different ways of adding S-functions to the build process. Implicit Build Support When building models with S-functions, the build process adds rules, include paths, and source file names to the generated makefile. The source files (.h, .c, and .cpp) for the S-function must be in the same folder as the S-function MEX-file. Whether using the toolchain approach or template makefile approach for builds, the build process propagates this information through the toolchain or template makefile. .h .c .cpp If the file sfcnname.h exists in the same folder as the S-function MEX-file (for example, sfcnname.mexext), the folder is added to the include path. If the file sfcnname.c or sfcnname.cpp exists in the same folder as the S-function MEX-file, the build process adds a makefile rule for compiling files from that folder. When an S-function is not inlined with a TLC file, the build process must compile the S-function source file. To determine the name of the source file to add to the list of files to compile, the build process searches for sfcnname.cpp on the MATLAB path. If the source file is found, the build process adds the source file name to the makefile. If sfcnname.cpp is not found on the path, the build process adds the file name sfcnname.c to the makefile, whether or not it is on the MATLAB path. Note For the Simulink engine to find the MEX-file for simulation and code generation, it must exist on the MATLAB path or exist in our current MATLAB working folder. Specify Additional Source Files for an S-Function If your S-function has additional source file dependencies, you must add the names of the additional modules to the build process. Specify the file names: In the S-function modules field in the S-Function block parameter dialog box With the SFunctionModules parameter in a call to the set_param function For example, suppose you build your S-function with multiple modules. mex sfun_main.c sfun_module1.c sfun_module2.c You can then add the modules to the build process by doing one of the following: In the S-function block dialog box, specify sfun_main, sfun_module1, and sfun_module2 in the S-function modules field. At the MATLAB command prompt, enter: set_param(sfun_block,'SFunctionModules','sfun_module1 sfun_module2') Alternatively, you can define a variable to represent the parameter value. modules = 'sfun_module1 sfun_module2' set_param(sfun_block,'SFunctionModules', modules) The S-function modules field and SFunctionModules parameter do not support complete source file path specifications. To use the parameter, the code generator must find the additional source files when executing the makefile. For the code generator to locate the additional files, place them in the same folder as the S-function MEX-file. You can then leverage the implicit build support described in Implicit Build Support. When you are ready to generate code, force the code generator to rebuild the top model, as described in Control Regeneration of Top Model Code. For more complicated S-function file dependencies, such as specifying source files in other locations or specifying libraries or object files, use the rtwmakecfg.m API, as described in Use rtwmakecfg.m API to Customize Generated Makefiles. Use TLC Library Functions If you inline your S-function by writing a TLC file, you can add source file names to the build process by using the TLC library function LibAddToModelSources. For details, see LibAddSourceFileCustomSection(file, builtInSection, newSection). LibAddToModelSources This function does not support complete source file path specifications. The function assumes that the code generator can find the additional source files when executing the makefile. Another useful TLC library function is LibAddToCommonIncludes. Use this function in a #include statement to include S-function header files in the generated model.h header file. For details, see LibAddToCommonIncludes(incFileName). Precompile S-Function Libraries You can precompile new or updated S-function libraries (MEX-files) for a model by using the MATLAB language function rtw_precompile_libs. Using a specified model and a library build specification, this function builds and places the libraries in a precompiled library folder. rtw_precompile_libs By precompiling S-function libraries, you can optimize system builds. Once your precompiled libraries exist, the build process can omit library compilation from subsequent builds. For models that use numerous libraries, the time savings for build processing can be significant. To use rtw_precompile_libs: Set the library file suffix, including the file type extension, based on your system platform. Consider determining the type of platform, and then use the TargetLibSuffix parameter to set the library suffix accordingly. For example, when applying a suffix for a GRT target, you can set the suffix to _std.a for a UNIX® platform and _vcx64.lib for a Windows® platform. if isunix suffix = '_std.a'; else suffix = '_vcx64.lib'; end set_param(my_model,'TargetLibSuffix', suffix); There are a number of factors that influence the precompiled library suffix and extension. The following table provides examples for typical selections of system target file, the compiler toolchain, and other options that affect your choice of suffix and extension. For more information, examine the template make files in the matlab/rtw/c/grt folder or matlab/rtw/c/ert folder. Set the precompiled library folder. Use one of the following methods to set the precompiled library folder: Set the TargetPreCompLibLocation parameter, as described in Specify the Location of Precompiled Libraries. Set the makeInfo.precompile field in an rtwmakecfg.m function file. (For more information, see Use rtwmakecfg.m API to Customize Generated Makefiles.) If you set TargetPreCompLibLocation and makeInfo.precompile, the setting for TargetPreCompLibLocation takes precedence. The following command sets the precompiled library folder for model my_model to folder lib under the current working folder. set_param(my_model,'TargetPreCompLibLocation', fullfile(pwd,'lib')); If you set both the target folder for the precompiled library files and a target library file suffix, the build process detects whether any precompiled library files are missing while processing builds. Define a build specification. Set up a structure that defines a build specification. The following table describes fields that you can define in the structure. These fields are optional, except for rtwmakecfgDirs. rtwmakecfgDirs A cell array of character vectors that name the folders containing rtwmakecfg files for libraries to be precompiled. The function uses the Name and Location elements of makeInfo.library, as returned by rtwmakecfg, to specify the name and location of the precompiled libraries. If you set the TargetPreCompLibLocation parameter to specify the library folder, that setting overrides the makeInfo.library.Location setting. Note: The specified model must contain blocks that use precompiled libraries specified by the rtwmakecfg files because the TMF-to-makefile conversion generates the library rules only if the build process uses the libraries. libSuffix intOnlyBuild makeOpts addLibs A cell array of structures that specify libraries to be built that are not specified by an rtwmakecfg function. Each structure must be defined with two fields that are character arrays: libName — the name of the library without a suffix libLoc — the location for the precompiled library The target makefile (TMF) can specify other libraries and how those libraries are built. Use this field to precompile those libraries. The following commands set up build specification build_spec, which indicates that the files to be compiled are in folder src under the current working folder. build_spec = []; build_spec.rtwmakecfgDirs = {fullfile(pwd,'src')}; Issue a call to rtw_precompile_libs. The call must specify the model for which you want to build the precompiled libraries and the build specification. For example: rtw_precompile_libs(my_model,build_spec); External Code Integration of Libraries and C/C++ Code with Simulink Real-Time Models Considerations for Integrating Third-Party Libraries and External Code into Simulink Real-Time When integrating code into Simulink® Real-Time™ applications, start by following the guidance in Build Integrated Code Within the Simulink Environment. Developers who integrate C/C++ code with Simulink Real-Time applications notice some differences when they migrate the code that they integrated with Simulink Real-Time applications from previous releases to R2020b and later releases. These differences include: In release R2020a and previous releases, the On-Time RTOS on the Speedgoat® target computer shared some libraries and system calls with Windows®. In release R2020b and later releases, the QNX® Neutrino® RTOS on the target computer does not share libraries or system calls specific to Windows. In release R2020a and previous releases, developers could use Microsoft® Visual Studio® to compile libraries to integrate with Simulink Real-Time applications. In release R2020b and later releases, you cannot use the Microsoft Visual Studio compiler for this purpose. You can configure Microsoft Visual Studio to use the QNX Neutrino compiler from the Simulink Real-Time target support package. In R2020b and later releases, developers use cross-compiling to produce libraries on their development computer for deployment to their target computer. Value of Upgrading Your C/C++ Code for Integration into Simulink Real-Time By updating your C/C++ code for integration into your Simulink Real-Time application, you gain these benefits: Leverage the QNX Neutrino 64-bit and POSIX® compatible RTOS. Code directly in C++ or wrap your legacy C code. Use the code editor of your choice. For instance, customizing Visual Studio Code with the source files and shipped QCC compiler from the Simulink Real-Time Target Support Package provides a similar experience to a full IDE. Leverage the precompiled QNX Neutrino libraries and headers that are included in Simulink Real-Time to extend the functionality of your real-time application. Integrate any C/C++ application based on modern build and package software such as CMake. Approaches for C/C++ Code Integration into Simulink Real-Time There are advantages and disadvantages to each of these external code integration approaches. Approach 1: Directly Call C/C++ Code. In this approach, you ​use C Caller or C Function blocks in the model. For more information, see Integrate C/C++ Code Using C Function Blocks.​ Advantages​: There is no need to compile source code before building the model.​ Disadvantages: This approach is ​hard to use for complex projects that have many files and dependencies​. Approach 2: Build, link, and use static libraries (.a files)​ Advantages​: All required files are packed in the real-time application MLDATX file. In this approach, ​there is no need to install libraries on the target. And, this approach lets you ​protect your intellectual property.​ Disadvantages​: This approach is non-modular. A change in the library requires rebuilding the whole real-time application​. Also, this approach tends to produce larger real-time application MLDATX files.​ Approach 3: Build, deploy and use shared objects (.so files)​ Advantages​: This approach is modular. You can build the real-time application and shared object independently​. Also, this approach tends to produce smaller real-time application MLDATX files. And this approach lets you protect your intellectual property.​ Disadvantages: ​In this approach, you need to access the target computer file system before running the real-time application and install (copy) the shared objects​ to any of the common lib paths on the target computers. Build Libraries from Source Code for Simulink Real-Time To integrate external code in a real-time application, the most flexible approaches are to build static libraries or shared objects from source code. The library build workflow is similar to the workflow used by most developers for release R2020a and previous releases. In those releases, the library build workflow for the target computer On-Time RTOS produced static libraries built with Microsoft Visual Studio and produced .lib files. You achieve better usability when working with complex C++ projects that have many dependencies and source code files. S-functions offer better granularity when handling third-party libraries in Simulink. S-functions enable the flexibility to use the same S-function source code with different platforms, including simulation on the desktop in different operating systems. The S-functions are deployed and function in real-time on a target computer. Cross-compiling is compiling a library for a target operating system (for example, QNX Neutrino RTOS) on a development operating system (for example, Windows). Some cross-compiling considerations for Simulink Real-Time are: Choice of development environment. Many modern C++ projects use the CMake build environment. For more information, see the CMake website. Extensibility of development environment. For example, it is a common practice to extend most common CMake support for the QNX Neutrino RTOS by leveraging similarities with the UNIX® OS and its POSIX compatibility. In your libraries, save cross-compiling libraries, including dependencies that might be already included in the Simulink Real-Time Target Support Package. These libraries can be linked to other C++ projects. The suggested workflow for integration of complex C++ applications into Simulink Real-Time is: Start from a C++ project with CMake as the build environment.​ Set the dependencies, such as headers and libraries, in your Simulink model.​ On the development computer, cross-compile libraries for the QNX Neutrino RTOS on the target computer.​ Create an S-function, for instance using the S-function Builder block or a handwritten C-MEX S-function, as the main function that calls the C++ functions defined in the header files and implemented in the compiled libraries for the QNX Neutrino RTOS​. Build the real-time application. ​ By using SSH or FTP, copy your cross-compiled libraries to a location on the target computer where they can be found and loaded at run time. The recommended locations are /lib, /usr/lib, or /usr/local/lib. Load and run the real-time application. External Code Integration for S-Functions and Simulink Real-Time When you include static libraries or shared objects in S-functions for external code integration with a real-time application, there are some tips for your development. When building from Simulink: Use rtwmakecfg.m and makeInfo object to map libraries and header files. For more information, see Use makecfg to Customize Generated Makefiles for S-Functions. function makeInfo = rtwmakecfg​ proj = currentProject;​ rootPath = proj.RootFolder;​ makeInfo.linkLibsObjs = {};​ sysTarget = get_param(bdroot, 'RTWSystemTargetFile');​ switch sysTarget​ case 'speedgoat.tlc'​ makeInfo.includePath = '<includePath>';​ makeInfo.linkLibsObjs{end+1} = '<libraryPath>';​ otherwise​ error('No rtwmakecfg found for %s target file', sysTarget);​ end​ end​ Enable linking for different target files. Use macros, such as SIMULINK_REAL_TIME, in your source code to add lines at compile time for real-time simulation. SIMULINK_REAL_TIME is useful to wrap the LOG function calls. When cross-compiling, use macros such as __unix__ and __QNXNTO__ in your source code to add lines at compile time. Additional C/C++ Project for Simulink Real-Time The eCAL Toolbox for Simulink project on github.com/mathworks/ecal-toolbox shows complete external code integration with Simulink Real-Time, including S-function wrappers, rtwmakecfg customization, and shared object compilation. You also can simulate this example on your development computer. rtwmakecfg", "tags": ["LibAddSourceFileCustomSection", "LibAddToCommonIncludes", "R2020A", "R2020B"], "tokens": 4170, "timestamp": "2025-05-03T14:44:29Z", "hash": "78f4adf9142f8e246f64bcab94ca66a9"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-folder-names-with-spaces-or-special-characters-halt-model-builds.html", "title": "Troubleshoot Folder Names with Spaces or Special Characters Halt Model Builds", "markdown": "Troubleshoot Folder Names with Spaces or Special Characters Halt Model Builds When a space character appears the file path, the Simulink® Real-Time™ model build reports an error: Simulink Real-Time model build cannot use a file path with spaces for model build directory. When a special character, such as an open parenthesis character \"(\", appears in the file path, the model build reports an error: Error(s) encountered while building \"xxxx\" What This Issue Means For the Simulink Real-Time model build … message or for the Error(s) encountered while building … message, message indicates that a space character or special character appears in the file path. The QNX® Neutrino® toolchain for the code generation target is not compatible with file paths that contain spaces or special characters, the model build halts and does not output a real-time application. Try This Workaround Try these workaround options to resolve the model build errors. Create a Build Folder Create a folder name that does not have spaces or special characters in it. Build your model in that folder. Map the Build Folder Map the folder name or path that has spaces or special characters in it to a folder name or path without spaces or special characters. Build your model in the mapped folder. Build Process Support for File and Folder Names Filenames with Spaces For the build process that uses ToolchainInfo objects, only these toolchains support the use of filenames containing spaces: ToolchainInfo GNU gcc/g++ | gmake (64-bit Linux) on Linux® MinGW64 | gmake (64-bit Windows) on Windows® Xcode with Clang | gmake (64-bit Mac) on Mac The build process that uses template makefiles does not support the use of filenames containing spaces. Folder Names with Spaces On a Windows system, the code generator maps a drive corresponding to the MATLAB® installation folder for either of these conditions: The matlabroot folder is a UNC location. The path the matlabroot folder contains spaces, and the system has no alternative name support. These folder paths can contain spaces: The path to your MATLAB installation folder (matlabroot). For example, C:\\Program Files\\MATLAB\\R2015b The path to the current working folder where you start the build (pwd). For example, C:\\Users\\username\\Documents\\My Work. The path to the installation folder for a compiler that the build process uses. If your work environment includes one or more of the preceding scenarios, use the following support mechanisms for the build process: If you are using the toolchain approach to build generated code, the system support for spaces in folder names influences toolchain operation: For Linux systems and Windows systems with 8.3 name creation enabled, the toolchain manages spaces in folder names by using alternative names from the operating system. The toolchain uses the TransformPathsWithSpaces attribute to manage these names. addAttribute(toolchainObject, 'TransformPathsWithSpaces', true); The security permissions of drives and folders can determine whether the toolchain transforms the path. For example, if the path contains a folder with a security configuration that forbids 8.3 path transformations, the toolchain does not transform the path and the build process produces a warning. For Windows systems with 8.3 name creation disabled, the toolchain manages spaces in folder names by mapping a network drive using a batch file (.bat). This operation requires adding the RequiresBatchFile attribute to the toolchain definition. addAttribute(toolchainObject, 'RequiresBatchFile', true); When developing a toolchain for a Windows system, set both attributes. For more information about the toolchain attributes, see addAttribute. If you are using the template makefile approach to build generated code, the template makefile (.tmf) requires code to manage spaces in folder names. When the alternative folder names (Windows short names) differ from the file system folder names (Windows long names), add this code to the makefile. ALT_MATLAB_ROOT = |>ALT_MATLAB_ROOT<| ALT_MATLAB_BIN = |>ALT_MATLAB_BIN<| !if \"$(MATLAB_ROOT)\" != \"$(ALT_MATLAB_ROOT)\" MATLAB_ROOT = $(ALT_MATLAB_ROOT) !endif !if \"$(MATLAB_BIN)\" != \"$(ALT_MATLAB_BIN)\" MATLAB_BIN = $(ALT_MATLAB_BIN) !endif When the values of the location tokens are not equal, this code replaces MATLAB_ROOT with ALT_MATLAB_ROOT. The replacement indicates that the path to your MATLAB installation folder includes spaces. This code applies the same type of replacement for MATLAB_BIN with ALT_MATLAB_BIN. The preceding code is specific to nmake. For platform-specific examples, see the supplied template makefiles. With either build approach, when there is an issue with support for creation of alternate names (short names), build errors can occur on Windows. If a build generates an error message similar to the following message, see Troubleshooting Errors When Folder Names Have Spaces. NMAKE : fatal error U1073: don't know how to make ' ... When using operating system commands, such as system or dos, enclose paths that specify executable files or command parameters in double quotes (\" \"). For example: system('dir \"D:\\Applications\\Common Files\"') This table provides a summary of build folder support and limitations for Windows. \\\\networkdrive\\matlab\\R20xxb T:\\ C:\\Program Files\\MATLAB\\R20xxb T:\\R20xxb C:\\Program Files\\MATLAB\\R20xxb sp1 rtwmakecfg.m Model configuration parameter Additional build information Code replacement library getShortPathName() NtfsDisable8dot3NameCreation NTFS file system with short path name support disabled ReFS file system (this file system does not support short path names) Troubleshooting Errors When Folder Names Have Spaces On Windows, when there is an issue with support for creation of short filenames, build process errors can occur. When this issue affects a build, you see an error message similar to: NMAKE : fatal error U1073: don't know how to make 'C:\\Work\\My' This message can occur if a space in the folder name (C:\\Work\\My Models) prevents the build process from finding the model or a file to build. For descriptions of the build-related folders that are sensitive to a space in the folder name or path, see Folder Names with Spaces. To avoid issues from folder names with spaces when Windows short filename support for filenames is disabled, do not use paths with spaces. For example, install third-party software to paths without spaces. Do not use paths with spaces for folders containing your models, source files, or libraries. An issue can occur with builds that use folder names with spaces, because it is possible to disable Windows alternate name support. The build process uses this alternate name support on Windows systems. There are many terms for this file, folder, and path alternate name support: 8.3 name DOS path short filename (SFN, ShortFileName) long name alias Windows path alias Verify the type of file system that the drive uses. In Windows Explorer, right-click the drive icon and select properties. If the file system is ReFS (Resilient File System), it is an issue. The ReFS does not provide short filename support. Except for the MATLAB installation folder, the build process does not support folder names with spaces for the ReFS file system. If your work environment requires short filename support for the build folder or for additional external code folders, do not use ReFS. If the file system is NTFS (New Technology File System), it is possible that the build error is related to a registry setting incompatibility. Continue with troubleshooting steps. The error could stem from an issue with short filename support on a system using NTFS. Check the Windows registry setting that enables the creation of short names for files, folders, and paths. Open the Windows command prompt, running as administrator. For example, from the Windows Start menu, type cmd, right-click the cmd.exe icon, and select Run as administrator. Change to the windows\\system32 folder and query the NtfsDisable8dot3NameCreation status by typing: If the registry state of NtfsDisable8dot3NameCreation is not 0 (enable 8dot3 name creation for all volumes on the system), change the value to 0 by typing: Changing the registry setting enables creation of short names only for files and folders that are created after the change. To create short names for files created while short name creation was disabled, at the Windows command line, use the fsutil utility. To set the short name, the syntax is: For example, to create the short name PROGRA~1 for the long name C:\\Program Files, type: The C:\\Program Files folder name is in quotations because it has spaces. To verify that the short name was created, use the dir command with /x option to show short names. Folder Names with Special Characters The build process might produce an error if a build-related folder path contains: Unicode® characters that do not belong to the system locale. This limitation does not apply if the build process uses a Microsoft® Visual C++® compiler. A Japanese (multibyte) character where the final byte is equal to the 5C hexadecimal character. The make and compiler tools might incorrectly interpret the final byte as the '\\' (backslash) character. One or more of these characters: '&' (ampersand) ':' (colon) ';' (semicolon) '$' (dollar sign) '(' (left parenthesis) ')' (right parenthesis) '^' (circumflex accent) Very Long Folder Paths For the MinGW® compiler, the build process produces an error when the command line length exceeds the Windows limit of 32,767 characters. If this error occurs, check the length of include paths. You can reduce the command line length by building the generated code in a code generation folder that has a shorter name addAttribute", "tags": ["Error", "R2015B"], "tokens": 1915, "timestamp": "2025-05-03T14:44:29Z", "hash": "400846ead1d1cb014f8c8ae26494883c"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-missing-real-time-tab.html", "title": "Troubleshoot Missing Real-Time Tab", "markdown": "Troubleshoot Missing Real-Time Tab Where is the Real-Time tab? This tab is not visible in the Simulink® editor. What This Issue Means From the model configuration, the Simulink editor determines which tabs to display. The editor displays the Real-Time tab for models that are configured for Simulink Real-Time™. Try This Workaround To configure your model for Simulink Real-Time, in Simulink Editor, from the Apps tab, click Simulink Real-Time. This operation changes the code generation target for the model to a Simulink Real-Time system target file (STF) and applies other configuration parameter changes for compatibility. After changing the configuration, the Simulink editor displays the Real-Time tab for the model. Create and Run Real-Time Application from Simulink Model This tutorial begins with a non-real-time Simulink® model of a damped oscillator, slrt_ex_osc_nrt. slrt_ex_osc_nrt Open the Non-Real-Time Model Copy openExample Command Paste command in MATLAB to download and open example files model_nrt = 'slrt_ex_osc_nrt'; open_system(model_nrt); model_rt = 'slrt_ex_osc_rt'; open_system(model_rt); Transform Simulink Model to Real-Time Application Add Simulink Real-Time File Log Block In the MATLAB Command Window, type slrt_ex_osc_nrt. MATLAB loads the oscillator model and displays the Simulink block diagram. In Simulink Editor, from the Apps tab, click Simulink Real-Time. From the Real-Time tab Prepare section, click Library Browser. In the Simulink left pane, browse to and double-click the node Simulink Real-Time. From the list of I/O block categories, click node Logging. Click and drag the File Log block to the Simulink block diagram. Simulink adds a new real-time File Log block to the model. Connect the Mux output to the File Log block input. On the Simulation tab, from the Save button, click Save As. Enter a file name. For example, enter slrt_ex_osc_ucf, and then click OK. To open the unconfigured model slrt_ex_osc_ucf, in the MATLAB Command Window, type: model_ucf = 'slrt_ex_osc_ucf'; open_system(model_ucf); Set File Log Block Parameters In the MATLAB Command Window, type slrt_ex_osc_ucf. MATLAB loads the oscillator model and displays the Simulink block diagram. Double-click the File Log block. In the Decimation text box, type 1. This value means that data is collected at each sample interval. Click OK, and then from the Simulation tab, click Save. Set Configuration Parameters In the MATLAB Command Window, type slrt_ex_osc_ucf. From the Real-Time tab, click Hardware Settings. In the Configuration Parameters dialog box, click the Solver node. In the Solver selection section, from the Type list, select Fixed-step. From the Solver list, select a solver. For example, select the general-purpose solver ode4 (Runge-Kutta). Under Solver details, in the Fixed-step size (fundamental sample time) box, enter the sample time for the real-time application. For example, enter 0.00025 seconds (250 microseconds). After creating the real-time application, you can change this value. If you find that a value overloads the CPU on the target computer, try a larger Fixed-step size value, such as 0.0002 seconds. The sample times of the model blocks can be multiples only of Fixed-step size. If you enter 'auto' in Fixed-step size, the fundamental sample time is calculated from the sample times of the model blocks. Click OK. From the Apps tab, select Simulink Real-Time. This selection configures the system target file and other model settings for Simulink Real-Time. In the Simulation tab, from the Save button, click Save As. Enter a file name. For example, enter slrt_ex_osc_rt. Start Target Computer and Display Status Monitor Start the target computer. The target computer displays session 1 (default) and the target computer status monitor. Close Models bdclose(model_nrt); bdclose(model_rt); bdclose(model_ucf); Target | Mux | load", "tags": [], "tokens": 785, "timestamp": "2025-05-03T14:44:29Z", "hash": "5a329912743e557d4a60f862b11562ea"}
{"url": "https://in.mathworks.com/help/slrealtime/ug_upgrade/troubleshoot-system-upgrade-to-r2020b.html", "title": "Troubleshoot System Upgrade for R2020b", "markdown": "Troubleshoot System Upgrade for R2020b After upgrading Simulink Real-Time software to R2020b and installing the Simulink Real-Time Target Support Package, the system cannot download real-time applications to the target computer. What This Issue Means The upgrade for release R2020b requires software upgrades to the Simulink Real-Time software and the Speedgoat Target Machine software. Try This Workaround In R2020b, the change to a 64-bit POSIX compliant real-time operating system on the target computer requires a software upgrade for your Speedgoat® real-time target machine. For this upgrade, the Speedgoat I/O Blockset provides an interactive tool. To retain compatibility with previous versions of MATLAB, you can choose to upgrade the target machine to a dual-boot system where you can select the operating system at startup. Or, you can upgrade the target machine to use only the new operating system. For the upgrade, you need a USB drive and the target machine needs a keyboard and a monitor. To upgrade your software: Install Simulink Real-Time and other required products. Install the Simulink Real-Time Target Support Package by using the MATLAB Add-Ons menu. ​Install the Speedgoat I/O Blockset. Go to the Speedgoat customer portal. To start the target machine upgrade, in the MATLAB Command Window, type: speedgoat.migrateTarget For more information, go to the Speedgoat website.", "tags": ["R2020B"], "tokens": 263, "timestamp": "2025-05-03T14:44:29Z", "hash": "1aa77c705e3e89a416dc40622c2a0b69"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/etas-inca-troubleshooting.html", "title": "Troubleshoot ETAS Inca Operation", "markdown": "Troubleshoot ETAS Inca Operation Investigate issues that can occur when ETAS® Inca controls a real-time application. A third-party calibration tool (ETAS Inca) is not working with the real-time application. What This Issue Means You can use the ETAS Inca tool to view signals and tune parameters in the real-time application. For more information, see the steps in Prepare ASAP2 Data Description File. In addition to the limitations listed in ETAS Inca Limitations, there are various issues that can prevent the operation of this tool. Try This Workaround For ETAS Inca tool issues, try these workarounds. Simulation Data Inspector in Use Simulation Data Inspector and the third-party calibration tools (Vector CANape® and ETAS Inca) are mutually exclusive. If you use the Simulation Data Inspector to view signal data, you cannot use the calibration tools. If you use the calibration tools, you cannot use the Simulation Data Inspector to view signal data. Client Cannot Connect Check the IP address of the Speedgoat® target computer associated with the model and compare it to the address stored in the ASAP2 file. ASAP2 File Out of Date When you rebuild a Simulink® Real-Time™ application, update the ASAP2 file loaded in the calibration tool with the new version of the file. The ASAP2 file is valid only until the next time that you build the application. Cannot Disable Freeze Mode Remove the dataset file from the target file system and reset the parameters to the original values specified in your model. The dataset file is named flashdata_model_name.dat. Transport Layer Failure When a transport layer failure occurs, ETAS Inca can display this message: ERROR: Transport Layer Failure, Inconsistent MsgCounter This error appears in ETAS Inca when the incorrect setting is used for 'Counter Consistency Mode'. Make sure that the 'Counter Consistency Mode' is set to 'one counter for all CTOs+DTOs' in the hardware settings for your experiment. At ETAS, we provide high-performance hardware and software to capture all vehicle data - from ECUs, networks, buses, and sensors - without data loss. Our tools enable you to systematically and efficiently extract the information you truly need to master the mass of data. They help you optimize functions in operation for new models and variants, permanently increasing the value of your vehicle. Our engineering services and consulting services are available to assist with all your development needs. The open architecture, modular design, and support of industrial and automotive standards common to all ETAS products allow for flexible adaptation to different development requirements and existing infrastructures. Our software development solutions take your team from concept to delivery with virtualization, automated testing, and secure, efficient release cycles. We provide a highly automated, collaborative environment on the PC, on the network or in the cloud. Our openness to third-party and in-house solutions, certified standardization and comprehensive services give you a high degree of flexibility. ETAS offers comprehensive test and validation solutions, including software-in-the-loop (SiL) testing in the cloud and virtual validation. Our solutions enable you to efficiently and reliably test embedded systems and automotive cybersecurity, ensuring high performance, safety, and compliance with industry standards throughout the development lifecycle. At ETAS, we provide high-performance real-time environments, including basic software, middleware, and configuration tools, based on AUTOSAR Classic and Adaptive standards, as well as ADAS/AD and edge middleware solutions. Our vehicle software platform suite is a key enabler for seamless and reliable software integration in modern vehicles. We provide integrated authoring and diagnostic solutions with relevant repair and service data for manufacturers and workshops. Our connected cross-lifecycle diagnostics feature automated content generation and enable you to continuously monitor vehicle health as well as perform accurate troubleshooting and cloud-based predictive maintenance across the entire fleet. ETAS provides embedded software, such as HSM firmware and cryptographic libraries for microcontrollers, as well as security solutions for microprocessor systems and vehicle computers to protect against cyber-attacks. We also offer dedicated tools to improve system robustness, while our intrusion detection and prevention solution secures vehicles and fleets throughout their lifecycle. At ETAS, we offer security consulting, security testing services, risk management, and vulnerability management to improve the security resilience of automotive components or vehicle platforms. We also provide a product security organization framework to help you achieve compliance with current automotive cybersecurity standards and regulations. ETAS offers a centralized and comprehensive customer service for hardware products, which includes repair, maintenance, and calibration services. All services are carried out by professionals who are specialized in ETAS products and their services. To compete in the future mobility race, rapid software delivery is key. It allows you to integrate innovations faster. It keeps vehicles competitive and up to date. And it helps you meet customer expectations as quickly as possible. ADAS data acquisition & management are critical to the development of automated driving functions. ADAS/AD data recorded in the vehicle or across the fleet reduce test drive time and costs, and ensure that ADAS/AD systems operate safely and efficiently in real-world scenarios. Calibration of automotive electronics is an essential part of the development process of new vehicles from the first prototypes until after SOP. By parameterizing the control unit software, the behavior of the control and diagnostic functions can be easily adapted to different system variants or vehicle models. As the industry moves toward software-defined vehicles, new demands and opportunities are emerging for vehicle diagnostics. With cloud-based vehicle monitoring, on-demand vehicle diagnostics and software updates, and predictive analysis of failure probabilities, you can unlock value throughout the vehicle lifecycle. Increasingly connected vehicles present new cybersecurity risks. As a result, automotive-specific regulations mandate the implementation of cybersecurity measures. As an automotive OEM or supplier you need to ensure your products are cyber-mature, in compliance with international regulations and standards. Microcontroller programming is a cyclical routine task of OEMs and suppliers. The challenge is to adapt the software development process chain and make it as efficient as possible, while at the same time navigating a complex landscape of technical and regulatory challenges. As vehicles become \"computers on wheels\", cybersecurity challenges arise. In an increasingly connected ecosystem, it is essential to establish a robust, holistic security framework across the vehicle lifecycle and supply chain. Effectively managing vulnerabilities and securing vehicle computers and systems is key to successful SDV development. Virtualization, automation, and parallelization are key to accelerating automotive software testing. By virtualizing ECUs, vehicles, and environments, and integrating them into automated, cloud-based workflows, testing becomes faster and more efficient, paving the way for innovation in software-defined vehicles. As vehicles become more connected, cybersecurity has advanced to a major business factor for modern cars: software vulnerabilities have led to safety recalls, automotive-specific regulations mandate security in the largest markets, and automotive companies rank cyber incidents as a top business risk. Our vehicle software platform is crucial for integrating disparate software components, managing real-time data, and supporting scalable, updatable vehicle architectures. It bridges communication within the vehicle's software architecture, allowing applications to be developed, maintained, and upgraded independently. The central challenge in ADAS/AD function development is ensuring safety and reliability while achieving robust performance across diverse scenarios. This makes the development of such functions resource-intensive, requiring an iterative and data-driven approach, thorough validation, and continuous improvement. With the shift to electric vehicles. the demands on measurement, validation, and calibration systems are increasing. The aim is to create sophisticated energy management systems that reconcile limited battery capacity with the highest levels of comfort and performance. Even though differentiating functionalities are trending in the vehicle market, developers need a solid base of enabling technologies and software to relieve them from repetitive side quests. Free & open-source software (FOSS) unleashes the power of collaboration frees up your resources to accelerate on creating future customer value. The shift from traditional ECUs to centralized, zonal E/E architectures is accelerating as the industry moves toward software-defined vehicles. These new E/E architectures enable efficient, high-bandwidth communication but bring new challenges for OEMs and suppliers. The future of mobility is defined by software. Throughout its entire lifecycle, the vehicle can be optimized with new services and functions via software updates, customizing it to the driver’s needs. This opens up new digital business models for OEMs, fleet operators, and service providers. A software factory streamlines software development like an assembly line, optimizing workflows through automation, cloud solutions, and parallelization. It enhances collaboration, speeds up delivery, and reduces redundant tasks while maintaining safety and quality. At ETAS, we don't just talk about the future, we're building it today. We kickstart future mobility by combining the reliability of a leading automotive supplier with the agility of digital talent in one software factory. We are here to accelerate your journey into the future of mobility, providing immediate support from day one. At ETAS, diversity and inclusion are firmly anchored in our corporate culture. We value the different perspectives and talents of each individual. All employees have equal opportunities and are empowered to bring their authentic selves to work, thus contributing to a unique workplace. Our ETAS partnerships will grow together to become holistic partnership networks. These partner networks address the transformation of the automotive industry together with manufacturers and suppliers in an innovative and conscientious manner. We, at ETAS, are teaming up with software and consulting companies, device manufacturers, service providers, and infrastructure partners. Furthermore, we want to leverage synergies and innovation through active participation in committees, associations, and research projects. Quality is deeply rooted in the business principles at ETAS. We are committed to offer our customers only top-quality products and services that are compliant with international regulations and standards. To achieve and accomplish the best possible performance, we continuously improve our management system and regularly undergo audits and assessments. Visit our newsroom for the latest news about ETAS, our products and services, and the latest trends in software-defined mobility. Or subscribe to our newsletter and receive the latest news in your inbox. Get first-hand information live, and join us at numerous trade shows and conferences around the world. Here you will find an overview of the events where we participate with an exhibit or a lecture. The ETAS press room is our service for journalists, bloggers and online multipliers. Here you will find our press releases, related images, and contact information for your worldwide press contacts. Discover exciting career opportunities at ETAS. Join a team of innovators and grow your career in a supportive and dynamic environment. All-in-One Powertrain Calibration for ICE, EV, and Fuel Cells ETAS and ThunderSoft are joining forces to drive innovation in automotive software solutions ETAS at Auto Shanghai 2025: Innovations for software-defined vehicles Accredited calibration guarantees highest precision and reliability ADAS/AD function development Automotive cybersecurity Vehicle software platform E-mobility Free and open-source software (FOSS) New E/E architectures Software-defined vehicle Software factory Shift your software delivery performance into a higher gear Accelerating software development ADAS data acquisition & management Calibrating automotive electronics Cross lifecycle diagnostics Cybersecurity compliance & regulations Software development for deeply embedded microcontrollers Virtualization & automated testing Support & training Webinars Support Hotlines Join #TeamETAS and be part of a community where your potential is our priority. We are close to you, at 42 locations in Europe, Asia, and the Americas. ETAS Inca Limitations For ETAS® Inca, the Simulink® Real-Time™ software does not support: Connecting MATLAB® to the target computer while using ETAS Inca. Loading, starting, or stopping the real-time application by using ETAS Inca commands. To load, start, or stop the real-time application on the target computer, use the target computer command-line interface. For example: slrealtime load --AppName app_name slrealtime start slrealtime stop For more information, see Target Computer Command-Line Interface. ETAS Inca flash programming. Multiple simultaneous ETAS Inca connections to a single target computer. Tunability of parameters with ExportedGlobal storage class when the model has other parameters with PageSwitching storage class. As a work around you can: Place all the parameters you want to tune in model workspace. Or Change the default mapping for storage class from PageSwitching to default. The PageSwitching storage class is not used, and the page switching functionality is not available. Event mode data acquisition has the following limitations: Every piece of data that the Simulink Real-Time software adds to the event list slows the real-time application. The amount of data that you can observe depends on the model sample time and the speed of the target computer. It is possible to overload the target computer CPU to where data integrity is reduced. You can trace only signals and scalar parameters. You cannot trace vector parameters. Prepare ASAP2 Data Description File This example shows how to configure a Simulink® Real-Time™ model so that the build generates an ASAP2 (A2L) data description file for the real-time application. The real-time application models a damped oscillator that feeds into 1-D and 2-D lookup tables, which invert and rescale the input waveform. Open the Model Copy openExample Command Paste command in MATLAB to download and open example files model = 'slrt_ex_osc_cal'; open_system(model); Initial Setup Kg -- Parameter object for the Gain1 block DampedOsc, SignalGenerator, L_1D, L_2D -- Signal objects for output signals LUT_1D_obj, LUT_2D_obj -- 1-D and 2-D lookup tables data respectively SignalGenerator -- Test input data Set Up Parameters Value -- 400 Data type -- double Set Up Signals Minimum -- -10 Maximum -- 10 Data type* -- double Minimum -- -15 Maximum -- 15 Set Up Lookup Tables Number of table dimensions -- 1 Data specification -- Lookup table object Name -- LUT_1D_obj Number of table dimensions -- 2 Name -- LUT_2D_obj Generate Data Description File coder.asap2.export('slrt_ex_osc_cal', ... 'MapFile','slrt_ex_osc_cal_slrealtime_rtw/slrt_ex_osc_cal', ... 'Comments',false); Close All Open Files bdclose(model); n-D Lookup Table | coder.asap2.export", "tags": [], "tokens": 2737, "timestamp": "2025-05-03T14:44:29Z", "hash": "8aa39aff8b1f804679638c88715728d6"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/vector-canape-troubleshooting.html", "title": "Troubleshoot Vector CANape Operation", "markdown": "Troubleshoot Vector CANape Operation A third-party calibration tool (Vector CANape®) is not working with the real-time application. What This Issue Means You can use the Vector CANape tool to view signals and tune parameters in the real-time application. For more information, see the steps in Prepare ASAP2 Data Description File. In addition to the limitations listed in Vector CANape Limitations, there are various issues that can prevent the operation of this tool. Try This Workaround For Vector CANape tool issues, try these workarounds. Simulation Data Inspector in Use Simulation Data Inspector and the third-party calibration tools (Vector CANape and ETAS® Inca) are mutually exclusive. If you use the Simulation Data Inspector to view signal data, you cannot use the calibration tools. If you use the calibration tools, you cannot use the Simulation Data Inspector to view signal data. Client Cannot Connect Check the IP address of the Speedgoat® target computer associated with the model and compare it to the address stored in the ASAP2 file. ASAP2 File Out of Date When you rebuild a Simulink® Real-Time™ application, update the ASAP2 file loaded in the calibration tool with the new version of the file. The ASAP2 file is valid only until the next time that you build the application. Frequently selected 1. Region 2. Language Putting Engineers in the Fast Lane Vector in a Nutshell On Your Marks. Really a Tough Guy. Our Defense Against Cyber Attacks. It’s Good If Your Software Runs. Even Better If It Conquers Every Challenge. During Development Everyone Is in the Same Boat. Finally. Follow The Racing Line. Even When Developing. The Right Equipment. For Every Game. Cookie Information Strictly Necessary Cookies Functional Cookies Performance Cookies Targeting Cookies Vendors List Vector CANape Limitations For Vector CANape®, the Simulink® Real-Time™ software does not support: Connecting MATLAB® to the target computer while using Vector CANape. Loading, starting, or stopping the real-time application by using Vector CANape commands. To load, start, or stop the real-time application on the target computer, use the target computer command-line interface. For example: slrealtime load --AppName app_name slrealtime start slrealtime stop For more information, see Target Computer Command-Line Interface. Vector CANape flash programming. Multiple simultaneous Vector CANape connections to a single target computer. Event mode data acquisition has the following limitations: Every piece of data that the Simulink Real-Time software adds to the event list slows the real-time application. The amount of data that you can observe depends on the model sample time and the speed of the target computer. It is possible to overload the target computer CPU to where data integrity is reduced. You can trace only signals and scalar parameters. You cannot trace vector parameters.", "tags": [], "tokens": 536, "timestamp": "2025-05-03T14:44:29Z", "hash": "7ab5deb5451feba1848fef445576a5bb"}
{"url": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-cannot-load-shared-object-on-target-computer.html", "title": "Troubleshoot Cannot Load Shared Object on Target Computer", "markdown": "Troubleshoot Cannot Load Shared Object on Target Computer When loading and running on the target computer a real-time application that depends on a shared object (.so), the real-time application cannot run and load the library. In the system log, A message like this error appears: ldd:FATAL: Could not load library xyz.so What This Issue Means An error loading a shared object can indicate some issue with missing or corrupt library dependencies on the target computer. The issue could be: The download to the Speedgoat® target computer has modified or has removed some required files on the target computer. The download to the target computer put the library in a location that is not accessible when the real-time application runs. Try This Workaround These workarounds explore the possible issues. Check for Issues with Required Files To check for this issue, connect to the target computer, and then try to build, load, and run example model slrt_ex_osc. If working with the default target computer, in the MATLAB® Command Window, type: tg = slrealtime; connect(tg); openExample('slrealtime/SlrtAddIOBlocksToSimulinkModelExample'); open_system('slrt_ex_osc'); slbuild('slrt_ex_osc'); load('slrt_ex_osc'); start('slrt_ex_osc'); If you can successfully connect to the target computer and build, load, and run the real-time application, there is no issue with files from the Simulink Real-Time Target Support Package on the target computer. If you cannot complete those operations successfully, update the target computer software by using the force option. If working with the default target computer, in the MATLAB Command Window, type: update(tg,'force',true); After the software update, connect to the target computer and try to build, load, and run the real-time application.. Check Location of Shared Object on Target Computer To check for this issue, use SSH or FTP to examine the location of the shared object file on the target computer. For more information, see Execute Target Computer RTOS Commands at Target Computer Command Line. After you build the real-time application that links to a shared object, you must install the real-time application and the shared object on the target computer. Put the shared objects in a location on the target computer where they can be found and loaded at run time. The recommended locations are /lib, /usr/lib, or /usr/local/lib. Root access is required to copy or modify files in these locations. update | slrealtime.getSupportInfo", "tags": [], "tokens": 501, "timestamp": "2025-05-03T14:44:29Z", "hash": "bac24d1b67a99136baf5237dd849e86b"}
{"url": "https://www.mathworks.com/support/search.html", "title": "MathWorks Help Center website", "markdown": "MathWorks Help Center website Category Clear Resource Clear Source Clear Status Clear Filtering is not supported for AI generated responses. To narrow down the generated response, rewrite your search phrase to include more specific information. Sources Related searches", "tags": [], "tokens": 41, "timestamp": "2025-05-03T14:44:29Z", "hash": "e1333720ce3c0251af43b77846be9b6f"}
